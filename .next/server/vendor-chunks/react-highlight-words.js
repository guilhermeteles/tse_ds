/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-highlight-words";
exports.ids = ["vendor-chunks/react-highlight-words"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-highlight-words/dist/main.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-highlight-words/dist/main.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = /******/ function(modules) {\n    /******/ // The module cache\n    /******/ var installedModules = {};\n    /******/ /******/ // The require function\n    /******/ function __nested_webpack_require_178__(moduleId) {\n        /******/ /******/ // Check if module is in cache\n        /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports;\n        /******/ /******/ // Create a new module (and put it into the cache)\n        /******/ var module1 = installedModules[moduleId] = {\n            /******/ exports: {},\n            /******/ id: moduleId,\n            /******/ loaded: false\n        };\n        /******/ /******/ // Execute the module function\n        /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_178__);\n        /******/ /******/ // Flag the module as loaded\n        /******/ module1.loaded = true;\n        /******/ /******/ // Return the exports of the module\n        /******/ return module1.exports;\n    /******/ }\n    /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n    /******/ __nested_webpack_require_178__.m = modules;\n    /******/ /******/ // expose the module cache\n    /******/ __nested_webpack_require_178__.c = installedModules;\n    /******/ /******/ // __webpack_public_path__\n    /******/ __nested_webpack_require_178__.p = \"\";\n    /******/ /******/ // Load entry module and return exports\n    /******/ return __nested_webpack_require_178__(0);\n/******/ }([\n    /* 0 */ /***/ function(module1, exports, __nested_webpack_require_1492__) {\n        module1.exports = __nested_webpack_require_1492__(1);\n    /***/ },\n    /* 1 */ /***/ function(module1, exports, __nested_webpack_require_1623__) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        function _interopRequireDefault(obj) {\n            return obj && obj.__esModule ? obj : {\n                \"default\": obj\n            };\n        }\n        var _Highlighter = __nested_webpack_require_1623__(2);\n        var _Highlighter2 = _interopRequireDefault(_Highlighter);\n        exports[\"default\"] = _Highlighter2[\"default\"];\n        module1.exports = exports[\"default\"];\n    /***/ },\n    /* 2 */ /***/ function(module1, exports, __nested_webpack_require_2189__) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        var _extends = Object.assign || function(target) {\n            for(var i = 1; i < arguments.length; i++){\n                var source = arguments[i];\n                for(var key in source){\n                    if (Object.prototype.hasOwnProperty.call(source, key)) {\n                        target[key] = source[key];\n                    }\n                }\n            }\n            return target;\n        };\n        exports[\"default\"] = Highlighter;\n        function _interopRequireDefault(obj) {\n            return obj && obj.__esModule ? obj : {\n                \"default\": obj\n            };\n        }\n        function _objectWithoutProperties(obj, keys) {\n            var target = {};\n            for(var i in obj){\n                if (keys.indexOf(i) >= 0) continue;\n                if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n                target[i] = obj[i];\n            }\n            return target;\n        }\n        var _highlightWordsCore = __nested_webpack_require_2189__(3);\n        var _propTypes = __nested_webpack_require_2189__(4);\n        var _propTypes2 = _interopRequireDefault(_propTypes);\n        var _react = __nested_webpack_require_2189__(14);\n        var _memoizeOne = __nested_webpack_require_2189__(15);\n        var _memoizeOne2 = _interopRequireDefault(_memoizeOne);\n        Highlighter.propTypes = {\n            activeClassName: _propTypes2[\"default\"].string,\n            activeIndex: _propTypes2[\"default\"].number,\n            activeStyle: _propTypes2[\"default\"].object,\n            autoEscape: _propTypes2[\"default\"].bool,\n            className: _propTypes2[\"default\"].string,\n            findChunks: _propTypes2[\"default\"].func,\n            highlightClassName: _propTypes2[\"default\"].oneOfType([\n                _propTypes2[\"default\"].object,\n                _propTypes2[\"default\"].string\n            ]),\n            highlightStyle: _propTypes2[\"default\"].object,\n            highlightTag: _propTypes2[\"default\"].oneOfType([\n                _propTypes2[\"default\"].node,\n                _propTypes2[\"default\"].func,\n                _propTypes2[\"default\"].string\n            ]),\n            sanitize: _propTypes2[\"default\"].func,\n            searchWords: _propTypes2[\"default\"].arrayOf(_propTypes2[\"default\"].oneOfType([\n                _propTypes2[\"default\"].string,\n                _propTypes2[\"default\"].instanceOf(RegExp)\n            ])).isRequired,\n            textToHighlight: _propTypes2[\"default\"].string.isRequired,\n            unhighlightTag: _propTypes2[\"default\"].oneOfType([\n                _propTypes2[\"default\"].node,\n                _propTypes2[\"default\"].func,\n                _propTypes2[\"default\"].string\n            ]),\n            unhighlightClassName: _propTypes2[\"default\"].string,\n            unhighlightStyle: _propTypes2[\"default\"].object\n        };\n        /**\r\n\t * Highlights all occurrences of search terms (searchText) within a string (textToHighlight).\r\n\t * This function returns an array of strings and <span>s (wrapping highlighted words).\r\n\t */ function Highlighter(_ref) {\n            var _ref$activeClassName = _ref.activeClassName;\n            var activeClassName = _ref$activeClassName === undefined ? \"\" : _ref$activeClassName;\n            var _ref$activeIndex = _ref.activeIndex;\n            var activeIndex = _ref$activeIndex === undefined ? -1 : _ref$activeIndex;\n            var activeStyle = _ref.activeStyle;\n            var autoEscape = _ref.autoEscape;\n            var _ref$caseSensitive = _ref.caseSensitive;\n            var caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive;\n            var className = _ref.className;\n            var findChunks = _ref.findChunks;\n            var _ref$highlightClassName = _ref.highlightClassName;\n            var highlightClassName = _ref$highlightClassName === undefined ? \"\" : _ref$highlightClassName;\n            var _ref$highlightStyle = _ref.highlightStyle;\n            var highlightStyle = _ref$highlightStyle === undefined ? {} : _ref$highlightStyle;\n            var _ref$highlightTag = _ref.highlightTag;\n            var highlightTag = _ref$highlightTag === undefined ? \"mark\" : _ref$highlightTag;\n            var sanitize = _ref.sanitize;\n            var searchWords = _ref.searchWords;\n            var textToHighlight = _ref.textToHighlight;\n            var _ref$unhighlightTag = _ref.unhighlightTag;\n            var unhighlightTag = _ref$unhighlightTag === undefined ? \"span\" : _ref$unhighlightTag;\n            var _ref$unhighlightClassName = _ref.unhighlightClassName;\n            var unhighlightClassName = _ref$unhighlightClassName === undefined ? \"\" : _ref$unhighlightClassName;\n            var unhighlightStyle = _ref.unhighlightStyle;\n            var rest = _objectWithoutProperties(_ref, [\n                \"activeClassName\",\n                \"activeIndex\",\n                \"activeStyle\",\n                \"autoEscape\",\n                \"caseSensitive\",\n                \"className\",\n                \"findChunks\",\n                \"highlightClassName\",\n                \"highlightStyle\",\n                \"highlightTag\",\n                \"sanitize\",\n                \"searchWords\",\n                \"textToHighlight\",\n                \"unhighlightTag\",\n                \"unhighlightClassName\",\n                \"unhighlightStyle\"\n            ]);\n            var chunks = (0, _highlightWordsCore.findAll)({\n                autoEscape: autoEscape,\n                caseSensitive: caseSensitive,\n                findChunks: findChunks,\n                sanitize: sanitize,\n                searchWords: searchWords,\n                textToHighlight: textToHighlight\n            });\n            var HighlightTag = highlightTag;\n            var highlightIndex = -1;\n            var highlightClassNames = \"\";\n            var highlightStyles = undefined;\n            var lowercaseProps = function lowercaseProps(object) {\n                var mapped = {};\n                for(var key in object){\n                    mapped[key.toLowerCase()] = object[key];\n                }\n                return mapped;\n            };\n            var memoizedLowercaseProps = (0, _memoizeOne2[\"default\"])(lowercaseProps);\n            return (0, _react.createElement)(\"span\", _extends({\n                className: className\n            }, rest, {\n                children: chunks.map(function(chunk, index) {\n                    var text = textToHighlight.substr(chunk.start, chunk.end - chunk.start);\n                    if (chunk.highlight) {\n                        highlightIndex++;\n                        var highlightClass = undefined;\n                        if (typeof highlightClassName === \"object\") {\n                            if (!caseSensitive) {\n                                highlightClassName = memoizedLowercaseProps(highlightClassName);\n                                highlightClass = highlightClassName[text.toLowerCase()];\n                            } else {\n                                highlightClass = highlightClassName[text];\n                            }\n                        } else {\n                            highlightClass = highlightClassName;\n                        }\n                        var isActive = highlightIndex === +activeIndex;\n                        highlightClassNames = highlightClass + \" \" + (isActive ? activeClassName : \"\");\n                        highlightStyles = isActive === true && activeStyle != null ? Object.assign({}, highlightStyle, activeStyle) : highlightStyle;\n                        var props = {\n                            children: text,\n                            className: highlightClassNames,\n                            key: index,\n                            style: highlightStyles\n                        };\n                        // Don't attach arbitrary props to DOM elements; this triggers React DEV warnings (https://fb.me/react-unknown-prop)\n                        // Only pass through the highlightIndex attribute for custom components.\n                        if (typeof HighlightTag !== \"string\") {\n                            props.highlightIndex = highlightIndex;\n                        }\n                        return (0, _react.createElement)(HighlightTag, props);\n                    } else {\n                        return (0, _react.createElement)(unhighlightTag, {\n                            children: text,\n                            className: unhighlightClassName,\n                            key: index,\n                            style: unhighlightStyle\n                        });\n                    }\n                })\n            }));\n        }\n        module1.exports = exports[\"default\"];\n    /***/ },\n    /* 3 */ /***/ function(module1, exports) {\n        module1.exports = /******/ function(modules) {\n            /******/ // The module cache\n            /******/ var installedModules = {};\n            /******/ /******/ // The require function\n            /******/ function __nested_webpack_require_11220__(moduleId) {\n                /******/ /******/ // Check if module is in cache\n                /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports;\n                /******/ /******/ // Create a new module (and put it into the cache)\n                /******/ var module1 = installedModules[moduleId] = {\n                    /******/ exports: {},\n                    /******/ id: moduleId,\n                    /******/ loaded: false\n                };\n                /******/ /******/ // Execute the module function\n                /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_11220__);\n                /******/ /******/ // Flag the module as loaded\n                /******/ module1.loaded = true;\n                /******/ /******/ // Return the exports of the module\n                /******/ return module1.exports;\n            /******/ }\n            /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n            /******/ __nested_webpack_require_11220__.m = modules;\n            /******/ /******/ // expose the module cache\n            /******/ __nested_webpack_require_11220__.c = installedModules;\n            /******/ /******/ // __webpack_public_path__\n            /******/ __nested_webpack_require_11220__.p = \"\";\n            /******/ /******/ // Load entry module and return exports\n            /******/ return __nested_webpack_require_11220__(0);\n        /******/ }([\n            /* 0 */ /***/ function(module1, exports, __nested_webpack_require_12734__) {\n                module1.exports = __nested_webpack_require_12734__(1);\n            /***/ },\n            /* 1 */ /***/ function(module1, exports, __nested_webpack_require_12889__) {\n                \"use strict\";\n                Object.defineProperty(exports, \"__esModule\", {\n                    value: true\n                });\n                var _utils = __nested_webpack_require_12889__(2);\n                Object.defineProperty(exports, \"combineChunks\", {\n                    enumerable: true,\n                    get: function get() {\n                        return _utils.combineChunks;\n                    }\n                });\n                Object.defineProperty(exports, \"fillInChunks\", {\n                    enumerable: true,\n                    get: function get() {\n                        return _utils.fillInChunks;\n                    }\n                });\n                Object.defineProperty(exports, \"findAll\", {\n                    enumerable: true,\n                    get: function get() {\n                        return _utils.findAll;\n                    }\n                });\n                Object.defineProperty(exports, \"findChunks\", {\n                    enumerable: true,\n                    get: function get() {\n                        return _utils.findChunks;\n                    }\n                });\n            /***/ },\n            /* 2 */ /***/ function(module1, exports) {\n                \"use strict\";\n                Object.defineProperty(exports, \"__esModule\", {\n                    value: true\n                });\n                /**\n\t\t * Creates an array of chunk objects representing both higlightable and non highlightable pieces of text that match each search word.\n\t\t * @return Array of \"chunks\" (where a Chunk is { start:number, end:number, highlight:boolean })\n\t\t */ var findAll = exports.findAll = function findAll(_ref) {\n                    var autoEscape = _ref.autoEscape, _ref$caseSensitive = _ref.caseSensitive, caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive, _ref$findChunks = _ref.findChunks, findChunks = _ref$findChunks === undefined ? defaultFindChunks : _ref$findChunks, sanitize = _ref.sanitize, searchWords = _ref.searchWords, textToHighlight = _ref.textToHighlight;\n                    return fillInChunks({\n                        chunksToHighlight: combineChunks({\n                            chunks: findChunks({\n                                autoEscape: autoEscape,\n                                caseSensitive: caseSensitive,\n                                sanitize: sanitize,\n                                searchWords: searchWords,\n                                textToHighlight: textToHighlight\n                            })\n                        }),\n                        totalLength: textToHighlight ? textToHighlight.length : 0\n                    });\n                };\n                /**\n\t\t * Takes an array of {start:number, end:number} objects and combines chunks that overlap into single chunks.\n\t\t * @return {start:number, end:number}[]\n\t\t */ var combineChunks = exports.combineChunks = function combineChunks(_ref2) {\n                    var chunks = _ref2.chunks;\n                    chunks = chunks.sort(function(first, second) {\n                        return first.start - second.start;\n                    }).reduce(function(processedChunks, nextChunk) {\n                        // First chunk just goes straight in the array...\n                        if (processedChunks.length === 0) {\n                            return [\n                                nextChunk\n                            ];\n                        } else {\n                            // ... subsequent chunks get checked to see if they overlap...\n                            var prevChunk = processedChunks.pop();\n                            if (nextChunk.start <= prevChunk.end) {\n                                // It may be the case that prevChunk completely surrounds nextChunk, so take the\n                                // largest of the end indeces.\n                                var endIndex = Math.max(prevChunk.end, nextChunk.end);\n                                processedChunks.push({\n                                    start: prevChunk.start,\n                                    end: endIndex\n                                });\n                            } else {\n                                processedChunks.push(prevChunk, nextChunk);\n                            }\n                            return processedChunks;\n                        }\n                    }, []);\n                    return chunks;\n                };\n                /**\n\t\t * Examine text for any matches.\n\t\t * If we find matches, add them to the returned array as a \"chunk\" object ({start:number, end:number}).\n\t\t * @return {start:number, end:number}[]\n\t\t */ var defaultFindChunks = function defaultFindChunks(_ref3) {\n                    var autoEscape = _ref3.autoEscape, caseSensitive = _ref3.caseSensitive, _ref3$sanitize = _ref3.sanitize, sanitize = _ref3$sanitize === undefined ? identity : _ref3$sanitize, searchWords = _ref3.searchWords, textToHighlight = _ref3.textToHighlight;\n                    textToHighlight = sanitize(textToHighlight);\n                    return searchWords.filter(function(searchWord) {\n                        return searchWord;\n                    }) // Remove empty words\n                    .reduce(function(chunks, searchWord) {\n                        searchWord = sanitize(searchWord);\n                        if (autoEscape) {\n                            searchWord = escapeRegExpFn(searchWord);\n                        }\n                        var regex = new RegExp(searchWord, caseSensitive ? \"g\" : \"gi\");\n                        var match = void 0;\n                        while(match = regex.exec(textToHighlight)){\n                            var start = match.index;\n                            var end = regex.lastIndex;\n                            // We do not return zero-length matches\n                            if (end > start) {\n                                chunks.push({\n                                    start: start,\n                                    end: end\n                                });\n                            }\n                            // Prevent browsers like Firefox from getting stuck in an infinite loop\n                            // See http://www.regexguru.com/2008/04/watch-out-for-zero-length-matches/\n                            if (match.index == regex.lastIndex) {\n                                regex.lastIndex++;\n                            }\n                        }\n                        return chunks;\n                    }, []);\n                };\n                // Allow the findChunks to be overridden in findAll,\n                // but for backwards compatibility we export as the old name\n                exports.findChunks = defaultFindChunks;\n                /**\n\t\t * Given a set of chunks to highlight, create an additional set of chunks\n\t\t * to represent the bits of text between the highlighted text.\n\t\t * @param chunksToHighlight {start:number, end:number}[]\n\t\t * @param totalLength number\n\t\t * @return {start:number, end:number, highlight:boolean}[]\n\t\t */ var fillInChunks = exports.fillInChunks = function fillInChunks(_ref4) {\n                    var chunksToHighlight = _ref4.chunksToHighlight, totalLength = _ref4.totalLength;\n                    var allChunks = [];\n                    var append = function append(start, end, highlight) {\n                        if (end - start > 0) {\n                            allChunks.push({\n                                start: start,\n                                end: end,\n                                highlight: highlight\n                            });\n                        }\n                    };\n                    if (chunksToHighlight.length === 0) {\n                        append(0, totalLength, false);\n                    } else {\n                        var lastIndex = 0;\n                        chunksToHighlight.forEach(function(chunk) {\n                            append(lastIndex, chunk.start, false);\n                            append(chunk.start, chunk.end, true);\n                            lastIndex = chunk.end;\n                        });\n                        append(lastIndex, totalLength, false);\n                    }\n                    return allChunks;\n                };\n                function identity(value) {\n                    return value;\n                }\n                function escapeRegExpFn(str) {\n                    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n                }\n            /***/ }\n        ]);\n    //# sourceMappingURL=index.js.map\n    /***/ },\n    /* 4 */ /***/ function(module1, exports, __nested_webpack_require_21586__) {\n        /* WEBPACK VAR INJECTION */ (function(process) {\n            if (true) {\n                var REACT_ELEMENT_TYPE = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n                var isValidElement = function(object) {\n                    return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n                };\n                // By explicitly using `prop-types` you are opting into new development behavior.\n                // http://fb.me/prop-types-in-prod\n                var throwOnDirectAccess = true;\n                module1.exports = __nested_webpack_require_21586__(6)(isValidElement, throwOnDirectAccess);\n            } else {}\n        /* WEBPACK VAR INJECTION */ }).call(exports, __nested_webpack_require_21586__(5));\n    /***/ },\n    /* 5 */ /***/ function(module1, exports) {\n        // shim for using process in browser\n        var process = module1.exports = {};\n        // cached from whatever global is present so that test runners that stub it\n        // don't break things.  But we need to wrap it in a try catch in case it is\n        // wrapped in strict mode code which doesn't define any globals.  It's inside a\n        // function because try/catches deoptimize in certain engines.\n        var cachedSetTimeout;\n        var cachedClearTimeout;\n        function defaultSetTimout() {\n            throw new Error(\"setTimeout has not been defined\");\n        }\n        function defaultClearTimeout() {\n            throw new Error(\"clearTimeout has not been defined\");\n        }\n        (function() {\n            try {\n                if (typeof setTimeout === \"function\") {\n                    cachedSetTimeout = setTimeout;\n                } else {\n                    cachedSetTimeout = defaultSetTimout;\n                }\n            } catch (e) {\n                cachedSetTimeout = defaultSetTimout;\n            }\n            try {\n                if (typeof clearTimeout === \"function\") {\n                    cachedClearTimeout = clearTimeout;\n                } else {\n                    cachedClearTimeout = defaultClearTimeout;\n                }\n            } catch (e) {\n                cachedClearTimeout = defaultClearTimeout;\n            }\n        })();\n        function runTimeout(fun) {\n            if (cachedSetTimeout === setTimeout) {\n                //normal enviroments in sane situations\n                return setTimeout(fun, 0);\n            }\n            // if setTimeout wasn't available but was latter defined\n            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n                cachedSetTimeout = setTimeout;\n                return setTimeout(fun, 0);\n            }\n            try {\n                // when when somebody has screwed with setTimeout but no I.E. maddness\n                return cachedSetTimeout(fun, 0);\n            } catch (e) {\n                try {\n                    // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n                    return cachedSetTimeout.call(null, fun, 0);\n                } catch (e) {\n                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n                    return cachedSetTimeout.call(this, fun, 0);\n                }\n            }\n        }\n        function runClearTimeout(marker) {\n            if (cachedClearTimeout === clearTimeout) {\n                //normal enviroments in sane situations\n                return clearTimeout(marker);\n            }\n            // if clearTimeout wasn't available but was latter defined\n            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n                cachedClearTimeout = clearTimeout;\n                return clearTimeout(marker);\n            }\n            try {\n                // when when somebody has screwed with setTimeout but no I.E. maddness\n                return cachedClearTimeout(marker);\n            } catch (e) {\n                try {\n                    // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n                    return cachedClearTimeout.call(null, marker);\n                } catch (e) {\n                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n                    // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n                    return cachedClearTimeout.call(this, marker);\n                }\n            }\n        }\n        var queue = [];\n        var draining = false;\n        var currentQueue;\n        var queueIndex = -1;\n        function cleanUpNextTick() {\n            if (!draining || !currentQueue) {\n                return;\n            }\n            draining = false;\n            if (currentQueue.length) {\n                queue = currentQueue.concat(queue);\n            } else {\n                queueIndex = -1;\n            }\n            if (queue.length) {\n                drainQueue();\n            }\n        }\n        function drainQueue() {\n            if (draining) {\n                return;\n            }\n            var timeout = runTimeout(cleanUpNextTick);\n            draining = true;\n            var len = queue.length;\n            while(len){\n                currentQueue = queue;\n                queue = [];\n                while(++queueIndex < len){\n                    if (currentQueue) {\n                        currentQueue[queueIndex].run();\n                    }\n                }\n                queueIndex = -1;\n                len = queue.length;\n            }\n            currentQueue = null;\n            draining = false;\n            runClearTimeout(timeout);\n        }\n        process.nextTick = function(fun) {\n            var args = new Array(arguments.length - 1);\n            if (arguments.length > 1) {\n                for(var i = 1; i < arguments.length; i++){\n                    args[i - 1] = arguments[i];\n                }\n            }\n            queue.push(new Item(fun, args));\n            if (queue.length === 1 && !draining) {\n                runTimeout(drainQueue);\n            }\n        };\n        // v8 likes predictible objects\n        function Item(fun, array) {\n            this.fun = fun;\n            this.array = array;\n        }\n        Item.prototype.run = function() {\n            this.fun.apply(null, this.array);\n        };\n        process.title = \"browser\";\n        process.browser = true;\n        process.env = {};\n        process.argv = [];\n        process.version = \"\"; // empty string to avoid regexp issues\n        process.versions = {};\n        function noop() {}\n        process.on = noop;\n        process.addListener = noop;\n        process.once = noop;\n        process.off = noop;\n        process.removeListener = noop;\n        process.removeAllListeners = noop;\n        process.emit = noop;\n        process.prependListener = noop;\n        process.prependOnceListener = noop;\n        process.listeners = function(name) {\n            return [];\n        };\n        process.binding = function(name) {\n            throw new Error(\"process.binding is not supported\");\n        };\n        process.cwd = function() {\n            return \"/\";\n        };\n        process.chdir = function(dir) {\n            throw new Error(\"process.chdir is not supported\");\n        };\n        process.umask = function() {\n            return 0;\n        };\n    /***/ },\n    /* 6 */ /***/ function(module1, exports, __nested_webpack_require_29550__) {\n        /* WEBPACK VAR INJECTION */ (function(process) {\n            \"use strict\";\n            var emptyFunction = __nested_webpack_require_29550__(7);\n            var invariant = __nested_webpack_require_29550__(8);\n            var warning = __nested_webpack_require_29550__(9);\n            var assign = __nested_webpack_require_29550__(10);\n            var ReactPropTypesSecret = __nested_webpack_require_29550__(11);\n            var checkPropTypes = __nested_webpack_require_29550__(12);\n            module1.exports = function(isValidElement, throwOnDirectAccess) {\n                /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n                var FAUX_ITERATOR_SYMBOL = \"@@iterator\"; // Before Symbol spec.\n                /**\n\t   * Returns the iterator method function contained on the iterable object.\n\t   *\n\t   * Be sure to invoke the function with the iterable as context:\n\t   *\n\t   *     var iteratorFn = getIteratorFn(myIterable);\n\t   *     if (iteratorFn) {\n\t   *       var iterator = iteratorFn.call(myIterable);\n\t   *       ...\n\t   *     }\n\t   *\n\t   * @param {?object} maybeIterable\n\t   * @return {?function}\n\t   */ function getIteratorFn(maybeIterable) {\n                    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n                    if (typeof iteratorFn === \"function\") {\n                        return iteratorFn;\n                    }\n                }\n                /**\n\t   * Collection of methods that allow declaration and validation of props that are\n\t   * supplied to React components. Example usage:\n\t   *\n\t   *   var Props = require('ReactPropTypes');\n\t   *   var MyArticle = React.createClass({\n\t   *     propTypes: {\n\t   *       // An optional string prop named \"description\".\n\t   *       description: Props.string,\n\t   *\n\t   *       // A required enum prop named \"category\".\n\t   *       category: Props.oneOf(['News','Photos']).isRequired,\n\t   *\n\t   *       // A prop named \"dialog\" that requires an instance of Dialog.\n\t   *       dialog: Props.instanceOf(Dialog).isRequired\n\t   *     },\n\t   *     render: function() { ... }\n\t   *   });\n\t   *\n\t   * A more formal specification of how these methods are used:\n\t   *\n\t   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n\t   *   decl := ReactPropTypes.{type}(.isRequired)?\n\t   *\n\t   * Each and every declaration produces a function with the same signature. This\n\t   * allows the creation of custom validation functions. For example:\n\t   *\n\t   *  var MyLink = React.createClass({\n\t   *    propTypes: {\n\t   *      // An optional string or URI prop named \"href\".\n\t   *      href: function(props, propName, componentName) {\n\t   *        var propValue = props[propName];\n\t   *        if (propValue != null && typeof propValue !== 'string' &&\n\t   *            !(propValue instanceof URI)) {\n\t   *          return new Error(\n\t   *            'Expected a string or an URI for ' + propName + ' in ' +\n\t   *            componentName\n\t   *          );\n\t   *        }\n\t   *      }\n\t   *    },\n\t   *    render: function() {...}\n\t   *  });\n\t   *\n\t   * @internal\n\t   */ var ANONYMOUS = \"<<anonymous>>\";\n                // Important!\n                // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n                var ReactPropTypes = {\n                    array: createPrimitiveTypeChecker(\"array\"),\n                    bool: createPrimitiveTypeChecker(\"boolean\"),\n                    func: createPrimitiveTypeChecker(\"function\"),\n                    number: createPrimitiveTypeChecker(\"number\"),\n                    object: createPrimitiveTypeChecker(\"object\"),\n                    string: createPrimitiveTypeChecker(\"string\"),\n                    symbol: createPrimitiveTypeChecker(\"symbol\"),\n                    any: createAnyTypeChecker(),\n                    arrayOf: createArrayOfTypeChecker,\n                    element: createElementTypeChecker(),\n                    instanceOf: createInstanceTypeChecker,\n                    node: createNodeChecker(),\n                    objectOf: createObjectOfTypeChecker,\n                    oneOf: createEnumTypeChecker,\n                    oneOfType: createUnionTypeChecker,\n                    shape: createShapeTypeChecker,\n                    exact: createStrictShapeTypeChecker\n                };\n                /**\n\t   * inlined Object.is polyfill to avoid requiring consumers ship their own\n\t   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n\t   */ /*eslint-disable no-self-compare*/ function is(x, y) {\n                    // SameValue algorithm\n                    if (x === y) {\n                        // Steps 1-5, 7-10\n                        // Steps 6.b-6.e: +0 != -0\n                        return x !== 0 || 1 / x === 1 / y;\n                    } else {\n                        // Step 6.a: NaN == NaN\n                        return x !== x && y !== y;\n                    }\n                }\n                /*eslint-enable no-self-compare*/ /**\n\t   * We use an Error-like object for backward compatibility as people may call\n\t   * PropTypes directly and inspect their output. However, we don't use real\n\t   * Errors anymore. We don't inspect their stack anyway, and creating them\n\t   * is prohibitively expensive if they are created too often, such as what\n\t   * happens in oneOfType() for any type before the one that matched.\n\t   */ function PropTypeError(message) {\n                    this.message = message;\n                    this.stack = \"\";\n                }\n                // Make `instanceof Error` still work for returned errors.\n                PropTypeError.prototype = Error.prototype;\n                function createChainableTypeChecker(validate) {\n                    if (true) {\n                        var manualPropTypeCallCache = {};\n                        var manualPropTypeWarningCount = 0;\n                    }\n                    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n                        componentName = componentName || ANONYMOUS;\n                        propFullName = propFullName || propName;\n                        if (secret !== ReactPropTypesSecret) {\n                            if (throwOnDirectAccess) {\n                                // New behavior only for users of `prop-types` package\n                                invariant(false, \"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use `PropTypes.checkPropTypes()` to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n                            } else if ( true && typeof console !== \"undefined\") {\n                                // Old behavior for people using React.PropTypes\n                                var cacheKey = componentName + \":\" + propName;\n                                if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors\n                                manualPropTypeWarningCount < 3) {\n                                    warning(false, \"You are manually calling a React.PropTypes validation \" + \"function for the `%s` prop on `%s`. This is deprecated \" + \"and will throw in the standalone `prop-types` package. \" + \"You may be seeing this warning due to a third-party PropTypes \" + \"library. See https://fb.me/react-warning-dont-call-proptypes \" + \"for details.\", propFullName, componentName);\n                                    manualPropTypeCallCache[cacheKey] = true;\n                                    manualPropTypeWarningCount++;\n                                }\n                            }\n                        }\n                        if (props[propName] == null) {\n                            if (isRequired) {\n                                if (props[propName] === null) {\n                                    return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + (\"in `\" + componentName + \"`, but its value is `null`.\"));\n                                }\n                                return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required in \" + (\"`\" + componentName + \"`, but its value is `undefined`.\"));\n                            }\n                            return null;\n                        } else {\n                            return validate(props, propName, componentName, location, propFullName);\n                        }\n                    }\n                    var chainedCheckType = checkType.bind(null, false);\n                    chainedCheckType.isRequired = checkType.bind(null, true);\n                    return chainedCheckType;\n                }\n                function createPrimitiveTypeChecker(expectedType) {\n                    function validate(props, propName, componentName, location, propFullName, secret) {\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== expectedType) {\n                            // `propValue` being instance of, say, date/regexp, pass the 'object'\n                            // check, but we can offer a more precise error message here rather than\n                            // 'of type `object`'.\n                            var preciseType = getPreciseType(propValue);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + preciseType + \"` supplied to `\" + componentName + \"`, expected \") + (\"`\" + expectedType + \"`.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createAnyTypeChecker() {\n                    return createChainableTypeChecker(emptyFunction.thatReturnsNull);\n                }\n                function createArrayOfTypeChecker(typeChecker) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (typeof typeChecker !== \"function\") {\n                            return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside arrayOf.\");\n                        }\n                        var propValue = props[propName];\n                        if (!Array.isArray(propValue)) {\n                            var propType = getPropType(propValue);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an array.\"));\n                        }\n                        for(var i = 0; i < propValue.length; i++){\n                            var error = typeChecker(propValue, i, componentName, location, propFullName + \"[\" + i + \"]\", ReactPropTypesSecret);\n                            if (error instanceof Error) {\n                                return error;\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createElementTypeChecker() {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        if (!isValidElement(propValue)) {\n                            var propType = getPropType(propValue);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createInstanceTypeChecker(expectedClass) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (!(props[propName] instanceof expectedClass)) {\n                            var expectedClassName = expectedClass.name || ANONYMOUS;\n                            var actualClassName = getClassName(props[propName]);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + actualClassName + \"` supplied to `\" + componentName + \"`, expected \") + (\"instance of `\" + expectedClassName + \"`.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createEnumTypeChecker(expectedValues) {\n                    if (!Array.isArray(expectedValues)) {\n                         true ? warning(false, \"Invalid argument supplied to oneOf, expected an instance of array.\") : 0;\n                        return emptyFunction.thatReturnsNull;\n                    }\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        for(var i = 0; i < expectedValues.length; i++){\n                            if (is(propValue, expectedValues[i])) {\n                                return null;\n                            }\n                        }\n                        var valuesString = JSON.stringify(expectedValues);\n                        return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of value `\" + propValue + \"` \" + (\"supplied to `\" + componentName + \"`, expected one of \" + valuesString + \".\"));\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createObjectOfTypeChecker(typeChecker) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (typeof typeChecker !== \"function\") {\n                            return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside objectOf.\");\n                        }\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== \"object\") {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an object.\"));\n                        }\n                        for(var key in propValue){\n                            if (propValue.hasOwnProperty(key)) {\n                                var error = typeChecker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                                if (error instanceof Error) {\n                                    return error;\n                                }\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createUnionTypeChecker(arrayOfTypeCheckers) {\n                    if (!Array.isArray(arrayOfTypeCheckers)) {\n                         true ? warning(false, \"Invalid argument supplied to oneOfType, expected an instance of array.\") : 0;\n                        return emptyFunction.thatReturnsNull;\n                    }\n                    for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                        var checker = arrayOfTypeCheckers[i];\n                        if (typeof checker !== \"function\") {\n                            warning(false, \"Invalid argument supplied to oneOfType. Expected an array of check functions, but \" + \"received %s at index %s.\", getPostfixForTypeWarning(checker), i);\n                            return emptyFunction.thatReturnsNull;\n                        }\n                    }\n                    function validate(props, propName, componentName, location, propFullName) {\n                        for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                            var checker = arrayOfTypeCheckers[i];\n                            if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n                                return null;\n                            }\n                        }\n                        return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`.\"));\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createNodeChecker() {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (!isNode(props[propName])) {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`, expected a ReactNode.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createShapeTypeChecker(shapeTypes) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== \"object\") {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n                        }\n                        for(var key in shapeTypes){\n                            var checker = shapeTypes[key];\n                            if (!checker) {\n                                continue;\n                            }\n                            var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                            if (error) {\n                                return error;\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createStrictShapeTypeChecker(shapeTypes) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== \"object\") {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n                        }\n                        // We need to check all keys in case some are required but missing from\n                        // props.\n                        var allKeys = assign({}, props[propName], shapeTypes);\n                        for(var key in allKeys){\n                            var checker = shapeTypes[key];\n                            if (!checker) {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` key `\" + key + \"` supplied to `\" + componentName + \"`.\" + \"\\nBad object: \" + JSON.stringify(props[propName], null, \"  \") + \"\\nValid keys: \" + JSON.stringify(Object.keys(shapeTypes), null, \"  \"));\n                            }\n                            var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                            if (error) {\n                                return error;\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function isNode(propValue) {\n                    switch(typeof propValue){\n                        case \"number\":\n                        case \"string\":\n                        case \"undefined\":\n                            return true;\n                        case \"boolean\":\n                            return !propValue;\n                        case \"object\":\n                            if (Array.isArray(propValue)) {\n                                return propValue.every(isNode);\n                            }\n                            if (propValue === null || isValidElement(propValue)) {\n                                return true;\n                            }\n                            var iteratorFn = getIteratorFn(propValue);\n                            if (iteratorFn) {\n                                var iterator = iteratorFn.call(propValue);\n                                var step;\n                                if (iteratorFn !== propValue.entries) {\n                                    while(!(step = iterator.next()).done){\n                                        if (!isNode(step.value)) {\n                                            return false;\n                                        }\n                                    }\n                                } else {\n                                    // Iterator will provide entry [k,v] tuples rather than values.\n                                    while(!(step = iterator.next()).done){\n                                        var entry = step.value;\n                                        if (entry) {\n                                            if (!isNode(entry[1])) {\n                                                return false;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                return false;\n                            }\n                            return true;\n                        default:\n                            return false;\n                    }\n                }\n                function isSymbol(propType, propValue) {\n                    // Native Symbol.\n                    if (propType === \"symbol\") {\n                        return true;\n                    }\n                    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n                    if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n                        return true;\n                    }\n                    // Fallback for non-spec compliant Symbols which are polyfilled.\n                    if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n                        return true;\n                    }\n                    return false;\n                }\n                // Equivalent of `typeof` but with special handling for array and regexp.\n                function getPropType(propValue) {\n                    var propType = typeof propValue;\n                    if (Array.isArray(propValue)) {\n                        return \"array\";\n                    }\n                    if (propValue instanceof RegExp) {\n                        // Old webkits (at least until Android 4.0) return 'function' rather than\n                        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n                        // passes PropTypes.object.\n                        return \"object\";\n                    }\n                    if (isSymbol(propType, propValue)) {\n                        return \"symbol\";\n                    }\n                    return propType;\n                }\n                // This handles more types than `getPropType`. Only used for error messages.\n                // See `createPrimitiveTypeChecker`.\n                function getPreciseType(propValue) {\n                    if (typeof propValue === \"undefined\" || propValue === null) {\n                        return \"\" + propValue;\n                    }\n                    var propType = getPropType(propValue);\n                    if (propType === \"object\") {\n                        if (propValue instanceof Date) {\n                            return \"date\";\n                        } else if (propValue instanceof RegExp) {\n                            return \"regexp\";\n                        }\n                    }\n                    return propType;\n                }\n                // Returns a string that is postfixed to a warning about an invalid type.\n                // For example, \"undefined\" or \"of type array\"\n                function getPostfixForTypeWarning(value) {\n                    var type = getPreciseType(value);\n                    switch(type){\n                        case \"array\":\n                        case \"object\":\n                            return \"an \" + type;\n                        case \"boolean\":\n                        case \"date\":\n                        case \"regexp\":\n                            return \"a \" + type;\n                        default:\n                            return type;\n                    }\n                }\n                // Returns class name of the object, if any.\n                function getClassName(propValue) {\n                    if (!propValue.constructor || !propValue.constructor.name) {\n                        return ANONYMOUS;\n                    }\n                    return propValue.constructor.name;\n                }\n                ReactPropTypes.checkPropTypes = checkPropTypes;\n                ReactPropTypes.PropTypes = ReactPropTypes;\n                return ReactPropTypes;\n            };\n        /* WEBPACK VAR INJECTION */ }).call(exports, __nested_webpack_require_29550__(5));\n    /***/ },\n    /* 7 */ /***/ function(module1, exports) {\n        \"use strict\";\n        /**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * \n\t */ function makeEmptyFunction(arg) {\n            return function() {\n                return arg;\n            };\n        }\n        /**\n\t * This function accepts and discards inputs; it has no side effects. This is\n\t * primarily useful idiomatically for overridable function endpoints which\n\t * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n\t */ var emptyFunction = function emptyFunction() {};\n        emptyFunction.thatReturns = makeEmptyFunction;\n        emptyFunction.thatReturnsFalse = makeEmptyFunction(false);\n        emptyFunction.thatReturnsTrue = makeEmptyFunction(true);\n        emptyFunction.thatReturnsNull = makeEmptyFunction(null);\n        emptyFunction.thatReturnsThis = function() {\n            return this;\n        };\n        emptyFunction.thatReturnsArgument = function(arg) {\n            return arg;\n        };\n        module1.exports = emptyFunction;\n    /***/ },\n    /* 8 */ /***/ function(module1, exports, __nested_webpack_require_57082__) {\n        /* WEBPACK VAR INJECTION */ (function(process) {\n            \"use strict\";\n            /**\n\t * Use invariant() to assert state which your program assumes to be true.\n\t *\n\t * Provide sprintf-style format (only %s is supported) and arguments\n\t * to provide information about what broke and what you were\n\t * expecting.\n\t *\n\t * The invariant message will be stripped in production, but the invariant\n\t * will remain to ensure logic does not differ in production.\n\t */ var validateFormat = function validateFormat(format) {};\n            if (true) {\n                validateFormat = function validateFormat(format) {\n                    if (format === undefined) {\n                        throw new Error(\"invariant requires an error message argument\");\n                    }\n                };\n            }\n            function invariant(condition, format, a, b, c, d, e, f) {\n                validateFormat(format);\n                if (!condition) {\n                    var error;\n                    if (format === undefined) {\n                        error = new Error(\"Minified exception occurred; use the non-minified dev environment \" + \"for the full error message and additional helpful warnings.\");\n                    } else {\n                        var args = [\n                            a,\n                            b,\n                            c,\n                            d,\n                            e,\n                            f\n                        ];\n                        var argIndex = 0;\n                        error = new Error(format.replace(/%s/g, function() {\n                            return args[argIndex++];\n                        }));\n                        error.name = \"Invariant Violation\";\n                    }\n                    error.framesToPop = 1; // we don't care about invariant's own frame\n                    throw error;\n                }\n            }\n            module1.exports = invariant;\n        /* WEBPACK VAR INJECTION */ }).call(exports, __nested_webpack_require_57082__(5));\n    /***/ },\n    /* 9 */ /***/ function(module1, exports, __nested_webpack_require_59235__) {\n        /* WEBPACK VAR INJECTION */ (function(process) {\n            \"use strict\";\n            var emptyFunction = __nested_webpack_require_59235__(7);\n            /**\n\t * Similar to invariant but only logs a warning if the condition is not met.\n\t * This can be used to log issues in development environments in critical\n\t * paths. Removing the logging code for production environments will keep the\n\t * same logic and follow the same code paths.\n\t */ var warning = emptyFunction;\n            if (true) {\n                var printWarning = function printWarning(format) {\n                    for(var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    var argIndex = 0;\n                    var message = \"Warning: \" + format.replace(/%s/g, function() {\n                        return args[argIndex++];\n                    });\n                    if (typeof console !== \"undefined\") {\n                        console.error(message);\n                    }\n                    try {\n                        // --- Welcome to debugging React ---\n                        // This error was thrown as a convenience so that you can use this stack\n                        // to find the callsite that caused this warning to fire.\n                        throw new Error(message);\n                    } catch (x) {}\n                };\n                warning = function warning(condition, format) {\n                    if (format === undefined) {\n                        throw new Error(\"`warning(condition, format, ...args)` requires a warning \" + \"message argument\");\n                    }\n                    if (format.indexOf(\"Failed Composite propType: \") === 0) {\n                        return; // Ignore CompositeComponent proptype check.\n                    }\n                    if (!condition) {\n                        for(var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++){\n                            args[_key2 - 2] = arguments[_key2];\n                        }\n                        printWarning.apply(undefined, [\n                            format\n                        ].concat(args));\n                    }\n                };\n            }\n            module1.exports = warning;\n        /* WEBPACK VAR INJECTION */ }).call(exports, __nested_webpack_require_59235__(5));\n    /***/ },\n    /* 10 */ /***/ function(module1, exports) {\n        /*\n\tobject-assign\n\t(c) Sindre Sorhus\n\t@license MIT\n\t*/ \"use strict\";\n        /* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n        function toObject(val) {\n            if (val === null || val === undefined) {\n                throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n            }\n            return Object(val);\n        }\n        function shouldUseNative() {\n            try {\n                if (!Object.assign) {\n                    return false;\n                }\n                // Detect buggy property enumeration order in older V8 versions.\n                // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n                var test1 = new String(\"abc\"); // eslint-disable-line no-new-wrappers\n                test1[5] = \"de\";\n                if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n                    return false;\n                }\n                // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                var test2 = {};\n                for(var i = 0; i < 10; i++){\n                    test2[\"_\" + String.fromCharCode(i)] = i;\n                }\n                var order2 = Object.getOwnPropertyNames(test2).map(function(n) {\n                    return test2[n];\n                });\n                if (order2.join(\"\") !== \"0123456789\") {\n                    return false;\n                }\n                // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                var test3 = {};\n                \"abcdefghijklmnopqrst\".split(\"\").forEach(function(letter) {\n                    test3[letter] = letter;\n                });\n                if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n                    return false;\n                }\n                return true;\n            } catch (err) {\n                // We don't expect any of the above to throw, but better to be safe.\n                return false;\n            }\n        }\n        module1.exports = shouldUseNative() ? Object.assign : function(target, source) {\n            var from;\n            var to = toObject(target);\n            var symbols;\n            for(var s = 1; s < arguments.length; s++){\n                from = Object(arguments[s]);\n                for(var key in from){\n                    if (hasOwnProperty.call(from, key)) {\n                        to[key] = from[key];\n                    }\n                }\n                if (getOwnPropertySymbols) {\n                    symbols = getOwnPropertySymbols(from);\n                    for(var i = 0; i < symbols.length; i++){\n                        if (propIsEnumerable.call(from, symbols[i])) {\n                            to[symbols[i]] = from[symbols[i]];\n                        }\n                    }\n                }\n            }\n            return to;\n        };\n    /***/ },\n    /* 11 */ /***/ function(module1, exports) {\n        /**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t */ \"use strict\";\n        var ReactPropTypesSecret = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n        module1.exports = ReactPropTypesSecret;\n    /***/ },\n    /* 12 */ /***/ function(module1, exports, __nested_webpack_require_65280__) {\n        /* WEBPACK VAR INJECTION */ (function(process) {\n            \"use strict\";\n            if (true) {\n                var invariant = __nested_webpack_require_65280__(8);\n                var warning = __nested_webpack_require_65280__(9);\n                var ReactPropTypesSecret = __nested_webpack_require_65280__(11);\n                var loggedTypeFailures = {};\n            }\n            /**\n\t * Assert that the values match with the type specs.\n\t * Error messages are memorized and will only be shown once.\n\t *\n\t * @param {object} typeSpecs Map of name to a ReactPropType\n\t * @param {object} values Runtime values that need to be type-checked\n\t * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n\t * @param {string} componentName Name of the component for error messages.\n\t * @param {?Function} getStack Returns the component stack.\n\t * @private\n\t */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n                if (true) {\n                    for(var typeSpecName in typeSpecs){\n                        if (typeSpecs.hasOwnProperty(typeSpecName)) {\n                            var error;\n                            // Prop type validation may throw. In case they do, we don't want to\n                            // fail the render phase where it didn't fail before. So we log it.\n                            // After these have been cleaned up, we'll let them throw.\n                            try {\n                                // This is intentionally an invariant that gets caught. It's the same\n                                // behavior as without this statement except with a better message.\n                                invariant(typeof typeSpecs[typeSpecName] === \"function\", \"%s: %s type `%s` is invalid; it must be a function, usually from \" + \"the `prop-types` package, but received `%s`.\", componentName || \"React class\", location, typeSpecName, typeof typeSpecs[typeSpecName]);\n                                error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n                            } catch (ex) {\n                                error = ex;\n                            }\n                            warning(!error || error instanceof Error, \"%s: type specification of %s `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error);\n                            if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n                                // Only monitor this failure once because there tends to be a lot of the\n                                // same error.\n                                loggedTypeFailures[error.message] = true;\n                                var stack = getStack ? getStack() : \"\";\n                                warning(false, \"Failed %s type: %s%s\", location, error.message, stack != null ? stack : \"\");\n                            }\n                        }\n                    }\n                }\n            }\n            module1.exports = checkPropTypes;\n        /* WEBPACK VAR INJECTION */ }).call(exports, __nested_webpack_require_65280__(5));\n    /***/ },\n    /* 13 */ /***/ function(module1, exports, __nested_webpack_require_68794__) {\n        /**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t */ \"use strict\";\n        var emptyFunction = __nested_webpack_require_68794__(7);\n        var invariant = __nested_webpack_require_68794__(8);\n        var ReactPropTypesSecret = __nested_webpack_require_68794__(11);\n        module1.exports = function() {\n            function shim(props, propName, componentName, location, propFullName, secret) {\n                if (secret === ReactPropTypesSecret) {\n                    // It is still safe when called from React.\n                    return;\n                }\n                invariant(false, \"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use PropTypes.checkPropTypes() to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n            }\n            ;\n            shim.isRequired = shim;\n            function getShim() {\n                return shim;\n            }\n            ;\n            // Important!\n            // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n            var ReactPropTypes = {\n                array: shim,\n                bool: shim,\n                func: shim,\n                number: shim,\n                object: shim,\n                string: shim,\n                symbol: shim,\n                any: shim,\n                arrayOf: getShim,\n                element: shim,\n                instanceOf: getShim,\n                node: shim,\n                objectOf: getShim,\n                oneOf: getShim,\n                oneOfType: getShim,\n                shape: getShim,\n                exact: getShim\n            };\n            ReactPropTypes.checkPropTypes = emptyFunction;\n            ReactPropTypes.PropTypes = ReactPropTypes;\n            return ReactPropTypes;\n        };\n    /***/ },\n    /* 14 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n    /***/ },\n    /* 15 */ /***/ function(module1, exports) {\n        \"use strict\";\n        var simpleIsEqual = function simpleIsEqual(a, b) {\n            return a === b;\n        };\n        function index(resultFn) {\n            var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : simpleIsEqual;\n            var lastThis = void 0;\n            var lastArgs = [];\n            var lastResult = void 0;\n            var calledOnce = false;\n            var isNewArgEqualToLast = function isNewArgEqualToLast(newArg, index) {\n                return isEqual(newArg, lastArgs[index]);\n            };\n            var result = function result() {\n                for(var _len = arguments.length, newArgs = Array(_len), _key = 0; _key < _len; _key++){\n                    newArgs[_key] = arguments[_key];\n                }\n                if (calledOnce && lastThis === this && newArgs.length === lastArgs.length && newArgs.every(isNewArgEqualToLast)) {\n                    return lastResult;\n                }\n                calledOnce = true;\n                lastThis = this;\n                lastArgs = newArgs;\n                lastResult = resultFn.apply(this, newArgs);\n                return lastResult;\n            };\n            return result;\n        }\n        module1.exports = index;\n    /***/ }\n]); //# sourceMappingURL=main.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaGlnaGxpZ2h0LXdvcmRzL2Rpc3QvbWFpbi5qcyIsIm1hcHBpbmdzIjoiQUFBQUEsT0FBT0MsT0FBTyxHQUNMLE1BQUgsR0FBSSxTQUFTQyxPQUFPO0lBQzFCLE1BQU0sR0FBSSxtQkFBbUI7SUFDN0IsTUFBTSxHQUFJLElBQUlDLG1CQUFtQixDQUFDO0lBQ2xDLE1BQU0sR0FDTixNQUFNLEdBQUksdUJBQXVCO0lBQ2pDLE1BQU0sR0FBSSxTQUFTQyw4QkFBbUJBLENBQUNDLFFBQVE7UUFDL0MsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7UUFDekMsTUFBTSxHQUFLLElBQUdGLGdCQUFnQixDQUFDRSxTQUFTLEVBQ3hDLE1BQU0sR0FBTSxPQUFPRixnQkFBZ0IsQ0FBQ0UsU0FBUyxDQUFDSixPQUFPO1FBQ3JELE1BQU0sR0FDTixNQUFNLEdBQUssa0RBQWtEO1FBQzdELE1BQU0sR0FBSyxJQUFJRCxVQUFTRyxnQkFBZ0IsQ0FBQ0UsU0FBUyxHQUFHO1lBQ3JELE1BQU0sR0FBTUosU0FBUyxDQUFDO1lBQ3RCLE1BQU0sR0FBTUssSUFBSUQ7WUFDaEIsTUFBTSxHQUFNRSxRQUFRO1FBQ1Q7UUFDWCxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtRQUN6QyxNQUFNLEdBQUtMLE9BQU8sQ0FBQ0csU0FBUyxDQUFDRyxJQUFJLENBQUNSLFFBQU9DLE9BQU8sRUFBRUQsU0FBUUEsUUFBT0MsT0FBTyxFQUFFRyw4QkFBbUJBO1FBQzdGLE1BQU0sR0FDTixNQUFNLEdBQUssNEJBQTRCO1FBQ3ZDLE1BQU0sR0FBS0osUUFBT08sTUFBTSxHQUFHO1FBQzNCLE1BQU0sR0FDTixNQUFNLEdBQUssbUNBQW1DO1FBQzlDLE1BQU0sR0FBSyxPQUFPUCxRQUFPQyxPQUFPO0lBQ2hDLE1BQU0sR0FBSTtJQUNWLE1BQU0sR0FDTixNQUFNLEdBQ04sTUFBTSxHQUFJLGtEQUFrRDtJQUM1RCxNQUFNLEdBQUlHLDhCQUFtQkEsQ0FBQ0ss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Y0FBYzNDLENBQUMsRUFBRUMsQ0FBQztZQUM3QyxPQUFPRCxNQUFNQztRQUNmO1FBRUEsU0FBUzNNLE1BQU9zUCxRQUFRO1lBQ3RCLElBQUlDLFVBQVU1VCxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBSzZDLFlBQVk3QyxTQUFTLENBQUMsRUFBRSxHQUFHMFQ7WUFFbEYsSUFBSUcsV0FBVyxLQUFLO1lBQ3BCLElBQUlDLFdBQVcsRUFBRTtZQUNqQixJQUFJQyxhQUFhLEtBQUs7WUFDdEIsSUFBSUMsYUFBYTtZQUVqQixJQUFJQyxzQkFBc0IsU0FBU0Esb0JBQW9CQyxNQUFNLEVBQUU3UCxLQUFLO2dCQUNsRSxPQUFPdVAsUUFBUU0sUUFBUUosUUFBUSxDQUFDelAsTUFBTTtZQUN4QztZQUVBLElBQUk4UCxTQUFTLFNBQVNBO2dCQUNwQixJQUFLLElBQUk3QyxPQUFPdFIsVUFBVUMsTUFBTSxFQUFFbVUsVUFBVWhMLE1BQU1rSSxPQUFPQyxPQUFPLEdBQUdBLE9BQU9ELE1BQU1DLE9BQVE7b0JBQ3RGNkMsT0FBTyxDQUFDN0MsS0FBSyxHQUFHdlIsU0FBUyxDQUFDdVIsS0FBSztnQkFDakM7Z0JBRUEsSUFBSXlDLGNBQWNILGFBQWEsSUFBSSxJQUFJTyxRQUFRblUsTUFBTSxLQUFLNlQsU0FBUzdULE1BQU0sSUFBSW1VLFFBQVExRSxLQUFLLENBQUN1RSxzQkFBc0I7b0JBQy9HLE9BQU9GO2dCQUNUO2dCQUVBQyxhQUFhO2dCQUNiSCxXQUFXLElBQUk7Z0JBQ2ZDLFdBQVdNO2dCQUNYTCxhQUFhSixTQUFTcEssS0FBSyxDQUFDLElBQUksRUFBRTZLO2dCQUNsQyxPQUFPTDtZQUNUO1lBRUEsT0FBT0k7UUFDVDtRQUVBM1YsUUFBT0MsT0FBTyxHQUFHNEY7SUFHbEIsR0FBRyxHQUFHO0NBQ0ksR0FDVixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90YWlsd2luZHVpLXN5bnRheC8uL25vZGVfbW9kdWxlcy9yZWFjdC1oaWdobGlnaHQtd29yZHMvZGlzdC9tYWluLmpzP2I1ZGYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPVxuLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblx0XG5cdHZhciBfSGlnaGxpZ2h0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcblx0dmFyIF9IaWdobGlnaHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9IaWdobGlnaHRlcik7XG5cblx0ZXhwb3J0c1snZGVmYXVsdCddID0gX0hpZ2hsaWdodGVyMlsnZGVmYXVsdCddO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblx0XG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IEhpZ2hsaWdodGVyO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXHRcblx0ZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXHRcblx0dmFyIF9oaWdobGlnaHRXb3Jkc0NvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcblx0dmFyIF9wcm9wVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcblx0dmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblx0XG5cdHZhciBfcmVhY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblx0XG5cdHZhciBfbWVtb2l6ZU9uZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXHRcblx0dmFyIF9tZW1vaXplT25lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lbW9pemVPbmUpO1xuXHRcblx0SGlnaGxpZ2h0ZXIucHJvcFR5cGVzID0ge1xuXHQgIGFjdGl2ZUNsYXNzTmFtZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcsXG5cdCAgYWN0aXZlSW5kZXg6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLFxuXHQgIGFjdGl2ZVN0eWxlOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9iamVjdCxcblx0ICBhdXRvRXNjYXBlOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2wsXG5cdCAgY2xhc3NOYW1lOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZyxcblx0ICBmaW5kQ2h1bmtzOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgaGlnaGxpZ2h0Q2xhc3NOYW1lOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mVHlwZShbX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vYmplY3QsIF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nXSksXG5cdCAgaGlnaGxpZ2h0U3R5bGU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0LFxuXHQgIGhpZ2hsaWdodFRhZzogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10ubm9kZSwgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZ10pLFxuXHQgIHNhbml0aXplOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG5cdCAgc2VhcmNoV29yZHM6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uYXJyYXlPZihfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mVHlwZShbX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcsIF9wcm9wVHlwZXMyWydkZWZhdWx0J10uaW5zdGFuY2VPZihSZWdFeHApXSkpLmlzUmVxdWlyZWQsXG5cdCAgdGV4dFRvSGlnaGxpZ2h0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZy5pc1JlcXVpcmVkLFxuXHQgIHVuaGlnaGxpZ2h0VGFnOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mVHlwZShbX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5ub2RlLCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsIF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nXSksXG5cdCAgdW5oaWdobGlnaHRDbGFzc05hbWU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLFxuXHQgIHVuaGlnaGxpZ2h0U3R5bGU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0XG5cdH07XG5cdFxuXHQvKipcclxuXHQgKiBIaWdobGlnaHRzIGFsbCBvY2N1cnJlbmNlcyBvZiBzZWFyY2ggdGVybXMgKHNlYXJjaFRleHQpIHdpdGhpbiBhIHN0cmluZyAodGV4dFRvSGlnaGxpZ2h0KS5cclxuXHQgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgPHNwYW4+cyAod3JhcHBpbmcgaGlnaGxpZ2h0ZWQgd29yZHMpLlxyXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gSGlnaGxpZ2h0ZXIoX3JlZikge1xuXHQgIHZhciBfcmVmJGFjdGl2ZUNsYXNzTmFtZSA9IF9yZWYuYWN0aXZlQ2xhc3NOYW1lO1xuXHQgIHZhciBhY3RpdmVDbGFzc05hbWUgPSBfcmVmJGFjdGl2ZUNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJGFjdGl2ZUNsYXNzTmFtZTtcblx0ICB2YXIgX3JlZiRhY3RpdmVJbmRleCA9IF9yZWYuYWN0aXZlSW5kZXg7XG5cdCAgdmFyIGFjdGl2ZUluZGV4ID0gX3JlZiRhY3RpdmVJbmRleCA9PT0gdW5kZWZpbmVkID8gLTEgOiBfcmVmJGFjdGl2ZUluZGV4O1xuXHQgIHZhciBhY3RpdmVTdHlsZSA9IF9yZWYuYWN0aXZlU3R5bGU7XG5cdCAgdmFyIGF1dG9Fc2NhcGUgPSBfcmVmLmF1dG9Fc2NhcGU7XG5cdCAgdmFyIF9yZWYkY2FzZVNlbnNpdGl2ZSA9IF9yZWYuY2FzZVNlbnNpdGl2ZTtcblx0ICB2YXIgY2FzZVNlbnNpdGl2ZSA9IF9yZWYkY2FzZVNlbnNpdGl2ZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGNhc2VTZW5zaXRpdmU7XG5cdCAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lO1xuXHQgIHZhciBmaW5kQ2h1bmtzID0gX3JlZi5maW5kQ2h1bmtzO1xuXHQgIHZhciBfcmVmJGhpZ2hsaWdodENsYXNzTmFtZSA9IF9yZWYuaGlnaGxpZ2h0Q2xhc3NOYW1lO1xuXHQgIHZhciBoaWdobGlnaHRDbGFzc05hbWUgPSBfcmVmJGhpZ2hsaWdodENsYXNzTmFtZSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJGhpZ2hsaWdodENsYXNzTmFtZTtcblx0ICB2YXIgX3JlZiRoaWdobGlnaHRTdHlsZSA9IF9yZWYuaGlnaGxpZ2h0U3R5bGU7XG5cdCAgdmFyIGhpZ2hsaWdodFN0eWxlID0gX3JlZiRoaWdobGlnaHRTdHlsZSA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmJGhpZ2hsaWdodFN0eWxlO1xuXHQgIHZhciBfcmVmJGhpZ2hsaWdodFRhZyA9IF9yZWYuaGlnaGxpZ2h0VGFnO1xuXHQgIHZhciBoaWdobGlnaHRUYWcgPSBfcmVmJGhpZ2hsaWdodFRhZyA9PT0gdW5kZWZpbmVkID8gJ21hcmsnIDogX3JlZiRoaWdobGlnaHRUYWc7XG5cdCAgdmFyIHNhbml0aXplID0gX3JlZi5zYW5pdGl6ZTtcblx0ICB2YXIgc2VhcmNoV29yZHMgPSBfcmVmLnNlYXJjaFdvcmRzO1xuXHQgIHZhciB0ZXh0VG9IaWdobGlnaHQgPSBfcmVmLnRleHRUb0hpZ2hsaWdodDtcblx0ICB2YXIgX3JlZiR1bmhpZ2hsaWdodFRhZyA9IF9yZWYudW5oaWdobGlnaHRUYWc7XG5cdCAgdmFyIHVuaGlnaGxpZ2h0VGFnID0gX3JlZiR1bmhpZ2hsaWdodFRhZyA9PT0gdW5kZWZpbmVkID8gJ3NwYW4nIDogX3JlZiR1bmhpZ2hsaWdodFRhZztcblx0ICB2YXIgX3JlZiR1bmhpZ2hsaWdodENsYXNzTmFtZSA9IF9yZWYudW5oaWdobGlnaHRDbGFzc05hbWU7XG5cdCAgdmFyIHVuaGlnaGxpZ2h0Q2xhc3NOYW1lID0gX3JlZiR1bmhpZ2hsaWdodENsYXNzTmFtZSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJHVuaGlnaGxpZ2h0Q2xhc3NOYW1lO1xuXHQgIHZhciB1bmhpZ2hsaWdodFN0eWxlID0gX3JlZi51bmhpZ2hsaWdodFN0eWxlO1xuXHRcblx0ICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2FjdGl2ZUNsYXNzTmFtZScsICdhY3RpdmVJbmRleCcsICdhY3RpdmVTdHlsZScsICdhdXRvRXNjYXBlJywgJ2Nhc2VTZW5zaXRpdmUnLCAnY2xhc3NOYW1lJywgJ2ZpbmRDaHVua3MnLCAnaGlnaGxpZ2h0Q2xhc3NOYW1lJywgJ2hpZ2hsaWdodFN0eWxlJywgJ2hpZ2hsaWdodFRhZycsICdzYW5pdGl6ZScsICdzZWFyY2hXb3JkcycsICd0ZXh0VG9IaWdobGlnaHQnLCAndW5oaWdobGlnaHRUYWcnLCAndW5oaWdobGlnaHRDbGFzc05hbWUnLCAndW5oaWdobGlnaHRTdHlsZSddKTtcblx0XG5cdCAgdmFyIGNodW5rcyA9ICgwLCBfaGlnaGxpZ2h0V29yZHNDb3JlLmZpbmRBbGwpKHtcblx0ICAgIGF1dG9Fc2NhcGU6IGF1dG9Fc2NhcGUsXG5cdCAgICBjYXNlU2Vuc2l0aXZlOiBjYXNlU2Vuc2l0aXZlLFxuXHQgICAgZmluZENodW5rczogZmluZENodW5rcyxcblx0ICAgIHNhbml0aXplOiBzYW5pdGl6ZSxcblx0ICAgIHNlYXJjaFdvcmRzOiBzZWFyY2hXb3Jkcyxcblx0ICAgIHRleHRUb0hpZ2hsaWdodDogdGV4dFRvSGlnaGxpZ2h0XG5cdCAgfSk7XG5cdCAgdmFyIEhpZ2hsaWdodFRhZyA9IGhpZ2hsaWdodFRhZztcblx0ICB2YXIgaGlnaGxpZ2h0SW5kZXggPSAtMTtcblx0ICB2YXIgaGlnaGxpZ2h0Q2xhc3NOYW1lcyA9ICcnO1xuXHQgIHZhciBoaWdobGlnaHRTdHlsZXMgPSB1bmRlZmluZWQ7XG5cdFxuXHQgIHZhciBsb3dlcmNhc2VQcm9wcyA9IGZ1bmN0aW9uIGxvd2VyY2FzZVByb3BzKG9iamVjdCkge1xuXHQgICAgdmFyIG1hcHBlZCA9IHt9O1xuXHQgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuXHQgICAgICBtYXBwZWRba2V5LnRvTG93ZXJDYXNlKCldID0gb2JqZWN0W2tleV07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbWFwcGVkO1xuXHQgIH07XG5cdCAgdmFyIG1lbW9pemVkTG93ZXJjYXNlUHJvcHMgPSAoMCwgX21lbW9pemVPbmUyWydkZWZhdWx0J10pKGxvd2VyY2FzZVByb3BzKTtcblx0XG5cdCAgcmV0dXJuICgwLCBfcmVhY3QuY3JlYXRlRWxlbWVudCkoJ3NwYW4nLCBfZXh0ZW5kcyh7XG5cdCAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuXHQgIH0sIHJlc3QsIHtcblx0ICAgIGNoaWxkcmVuOiBjaHVua3MubWFwKGZ1bmN0aW9uIChjaHVuaywgaW5kZXgpIHtcblx0ICAgICAgdmFyIHRleHQgPSB0ZXh0VG9IaWdobGlnaHQuc3Vic3RyKGNodW5rLnN0YXJ0LCBjaHVuay5lbmQgLSBjaHVuay5zdGFydCk7XG5cdFxuXHQgICAgICBpZiAoY2h1bmsuaGlnaGxpZ2h0KSB7XG5cdCAgICAgICAgaGlnaGxpZ2h0SW5kZXgrKztcblx0XG5cdCAgICAgICAgdmFyIGhpZ2hsaWdodENsYXNzID0gdW5kZWZpbmVkO1xuXHQgICAgICAgIGlmICh0eXBlb2YgaGlnaGxpZ2h0Q2xhc3NOYW1lID09PSAnb2JqZWN0Jykge1xuXHQgICAgICAgICAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG5cdCAgICAgICAgICAgIGhpZ2hsaWdodENsYXNzTmFtZSA9IG1lbW9pemVkTG93ZXJjYXNlUHJvcHMoaGlnaGxpZ2h0Q2xhc3NOYW1lKTtcblx0ICAgICAgICAgICAgaGlnaGxpZ2h0Q2xhc3MgPSBoaWdobGlnaHRDbGFzc05hbWVbdGV4dC50b0xvd2VyQ2FzZSgpXTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGhpZ2hsaWdodENsYXNzID0gaGlnaGxpZ2h0Q2xhc3NOYW1lW3RleHRdO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBoaWdobGlnaHRDbGFzcyA9IGhpZ2hsaWdodENsYXNzTmFtZTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHZhciBpc0FjdGl2ZSA9IGhpZ2hsaWdodEluZGV4ID09PSArYWN0aXZlSW5kZXg7XG5cdFxuXHQgICAgICAgIGhpZ2hsaWdodENsYXNzTmFtZXMgPSBoaWdobGlnaHRDbGFzcyArICcgJyArIChpc0FjdGl2ZSA/IGFjdGl2ZUNsYXNzTmFtZSA6ICcnKTtcblx0ICAgICAgICBoaWdobGlnaHRTdHlsZXMgPSBpc0FjdGl2ZSA9PT0gdHJ1ZSAmJiBhY3RpdmVTdHlsZSAhPSBudWxsID8gT2JqZWN0LmFzc2lnbih7fSwgaGlnaGxpZ2h0U3R5bGUsIGFjdGl2ZVN0eWxlKSA6IGhpZ2hsaWdodFN0eWxlO1xuXHRcblx0ICAgICAgICB2YXIgcHJvcHMgPSB7XG5cdCAgICAgICAgICBjaGlsZHJlbjogdGV4dCxcblx0ICAgICAgICAgIGNsYXNzTmFtZTogaGlnaGxpZ2h0Q2xhc3NOYW1lcyxcblx0ICAgICAgICAgIGtleTogaW5kZXgsXG5cdCAgICAgICAgICBzdHlsZTogaGlnaGxpZ2h0U3R5bGVzXG5cdCAgICAgICAgfTtcblx0XG5cdCAgICAgICAgLy8gRG9uJ3QgYXR0YWNoIGFyYml0cmFyeSBwcm9wcyB0byBET00gZWxlbWVudHM7IHRoaXMgdHJpZ2dlcnMgUmVhY3QgREVWIHdhcm5pbmdzIChodHRwczovL2ZiLm1lL3JlYWN0LXVua25vd24tcHJvcClcblx0ICAgICAgICAvLyBPbmx5IHBhc3MgdGhyb3VnaCB0aGUgaGlnaGxpZ2h0SW5kZXggYXR0cmlidXRlIGZvciBjdXN0b20gY29tcG9uZW50cy5cblx0ICAgICAgICBpZiAodHlwZW9mIEhpZ2hsaWdodFRhZyAhPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgIHByb3BzLmhpZ2hsaWdodEluZGV4ID0gaGlnaGxpZ2h0SW5kZXg7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICByZXR1cm4gKDAsIF9yZWFjdC5jcmVhdGVFbGVtZW50KShIaWdobGlnaHRUYWcsIHByb3BzKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gKDAsIF9yZWFjdC5jcmVhdGVFbGVtZW50KSh1bmhpZ2hsaWdodFRhZywge1xuXHQgICAgICAgICAgY2hpbGRyZW46IHRleHQsXG5cdCAgICAgICAgICBjbGFzc05hbWU6IHVuaGlnaGxpZ2h0Q2xhc3NOYW1lLFxuXHQgICAgICAgICAga2V5OiBpbmRleCxcblx0ICAgICAgICAgIHN0eWxlOiB1bmhpZ2hsaWdodFN0eWxlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblx0ICAgIH0pXG5cdCAgfSkpO1xuXHR9XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPVxuXHQvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG5cdC8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuXHQvKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cblx0LyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0LyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuXHQvKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdC8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG5cdC8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuXHQvKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG5cdC8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcblx0LyoqKioqKi8gXHRcdH07XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0LyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHQvKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHQvKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuXHQvKioqKioqLyBcdH1cblx0LyoqKioqKi9cblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcblx0LyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblx0LyoqKioqKi8gfSlcblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKi8gKFtcblx0LyogMCAqL1xuXHQvKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdFxuXHRcdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0XG5cdFxuXHQvKioqLyB9KSxcblx0LyogMSAqL1xuXHQvKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdFxuXHRcdCd1c2Ugc3RyaWN0Jztcblx0XHRcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHQgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0XG5cdFx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFx0XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjb21iaW5lQ2h1bmtzJywge1xuXHRcdCAgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHQgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdCAgICByZXR1cm4gX3V0aWxzLmNvbWJpbmVDaHVua3M7XG5cdFx0ICB9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdmaWxsSW5DaHVua3MnLCB7XG5cdFx0ICBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdCAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0ICAgIHJldHVybiBfdXRpbHMuZmlsbEluQ2h1bmtzO1xuXHRcdCAgfVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZmluZEFsbCcsIHtcblx0XHQgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHQgICAgcmV0dXJuIF91dGlscy5maW5kQWxsO1xuXHRcdCAgfVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZmluZENodW5rcycsIHtcblx0XHQgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHQgICAgcmV0dXJuIF91dGlscy5maW5kQ2h1bmtzO1xuXHRcdCAgfVxuXHRcdH0pO1xuXHRcblx0LyoqKi8gfSksXG5cdC8qIDIgKi9cblx0LyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcblx0XHQndXNlIHN0cmljdCc7XG5cdFx0XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICB2YWx1ZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgY2h1bmsgb2JqZWN0cyByZXByZXNlbnRpbmcgYm90aCBoaWdsaWdodGFibGUgYW5kIG5vbiBoaWdobGlnaHRhYmxlIHBpZWNlcyBvZiB0ZXh0IHRoYXQgbWF0Y2ggZWFjaCBzZWFyY2ggd29yZC5cblx0XHQgKiBAcmV0dXJuIEFycmF5IG9mIFwiY2h1bmtzXCIgKHdoZXJlIGEgQ2h1bmsgaXMgeyBzdGFydDpudW1iZXIsIGVuZDpudW1iZXIsIGhpZ2hsaWdodDpib29sZWFuIH0pXG5cdFx0ICovXG5cdFx0dmFyIGZpbmRBbGwgPSBleHBvcnRzLmZpbmRBbGwgPSBmdW5jdGlvbiBmaW5kQWxsKF9yZWYpIHtcblx0XHQgIHZhciBhdXRvRXNjYXBlID0gX3JlZi5hdXRvRXNjYXBlLFxuXHRcdCAgICAgIF9yZWYkY2FzZVNlbnNpdGl2ZSA9IF9yZWYuY2FzZVNlbnNpdGl2ZSxcblx0XHQgICAgICBjYXNlU2Vuc2l0aXZlID0gX3JlZiRjYXNlU2Vuc2l0aXZlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkY2FzZVNlbnNpdGl2ZSxcblx0XHQgICAgICBfcmVmJGZpbmRDaHVua3MgPSBfcmVmLmZpbmRDaHVua3MsXG5cdFx0ICAgICAgZmluZENodW5rcyA9IF9yZWYkZmluZENodW5rcyA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdEZpbmRDaHVua3MgOiBfcmVmJGZpbmRDaHVua3MsXG5cdFx0ICAgICAgc2FuaXRpemUgPSBfcmVmLnNhbml0aXplLFxuXHRcdCAgICAgIHNlYXJjaFdvcmRzID0gX3JlZi5zZWFyY2hXb3Jkcyxcblx0XHQgICAgICB0ZXh0VG9IaWdobGlnaHQgPSBfcmVmLnRleHRUb0hpZ2hsaWdodDtcblx0XHQgIHJldHVybiBmaWxsSW5DaHVua3Moe1xuXHRcdCAgICBjaHVua3NUb0hpZ2hsaWdodDogY29tYmluZUNodW5rcyh7XG5cdFx0ICAgICAgY2h1bmtzOiBmaW5kQ2h1bmtzKHtcblx0XHQgICAgICAgIGF1dG9Fc2NhcGU6IGF1dG9Fc2NhcGUsXG5cdFx0ICAgICAgICBjYXNlU2Vuc2l0aXZlOiBjYXNlU2Vuc2l0aXZlLFxuXHRcdCAgICAgICAgc2FuaXRpemU6IHNhbml0aXplLFxuXHRcdCAgICAgICAgc2VhcmNoV29yZHM6IHNlYXJjaFdvcmRzLFxuXHRcdCAgICAgICAgdGV4dFRvSGlnaGxpZ2h0OiB0ZXh0VG9IaWdobGlnaHRcblx0XHQgICAgICB9KVxuXHRcdCAgICB9KSxcblx0XHQgICAgdG90YWxMZW5ndGg6IHRleHRUb0hpZ2hsaWdodCA/IHRleHRUb0hpZ2hsaWdodC5sZW5ndGggOiAwXG5cdFx0ICB9KTtcblx0XHR9O1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRha2VzIGFuIGFycmF5IG9mIHtzdGFydDpudW1iZXIsIGVuZDpudW1iZXJ9IG9iamVjdHMgYW5kIGNvbWJpbmVzIGNodW5rcyB0aGF0IG92ZXJsYXAgaW50byBzaW5nbGUgY2h1bmtzLlxuXHRcdCAqIEByZXR1cm4ge3N0YXJ0Om51bWJlciwgZW5kOm51bWJlcn1bXVxuXHRcdCAqL1xuXHRcdHZhciBjb21iaW5lQ2h1bmtzID0gZXhwb3J0cy5jb21iaW5lQ2h1bmtzID0gZnVuY3Rpb24gY29tYmluZUNodW5rcyhfcmVmMikge1xuXHRcdCAgdmFyIGNodW5rcyA9IF9yZWYyLmNodW5rcztcblx0XHRcblx0XHQgIGNodW5rcyA9IGNodW5rcy5zb3J0KGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG5cdFx0ICAgIHJldHVybiBmaXJzdC5zdGFydCAtIHNlY29uZC5zdGFydDtcblx0XHQgIH0pLnJlZHVjZShmdW5jdGlvbiAocHJvY2Vzc2VkQ2h1bmtzLCBuZXh0Q2h1bmspIHtcblx0XHQgICAgLy8gRmlyc3QgY2h1bmsganVzdCBnb2VzIHN0cmFpZ2h0IGluIHRoZSBhcnJheS4uLlxuXHRcdCAgICBpZiAocHJvY2Vzc2VkQ2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuXHRcdCAgICAgIHJldHVybiBbbmV4dENodW5rXTtcblx0XHQgICAgfSBlbHNlIHtcblx0XHQgICAgICAvLyAuLi4gc3Vic2VxdWVudCBjaHVua3MgZ2V0IGNoZWNrZWQgdG8gc2VlIGlmIHRoZXkgb3ZlcmxhcC4uLlxuXHRcdCAgICAgIHZhciBwcmV2Q2h1bmsgPSBwcm9jZXNzZWRDaHVua3MucG9wKCk7XG5cdFx0ICAgICAgaWYgKG5leHRDaHVuay5zdGFydCA8PSBwcmV2Q2h1bmsuZW5kKSB7XG5cdFx0ICAgICAgICAvLyBJdCBtYXkgYmUgdGhlIGNhc2UgdGhhdCBwcmV2Q2h1bmsgY29tcGxldGVseSBzdXJyb3VuZHMgbmV4dENodW5rLCBzbyB0YWtlIHRoZVxuXHRcdCAgICAgICAgLy8gbGFyZ2VzdCBvZiB0aGUgZW5kIGluZGVjZXMuXG5cdFx0ICAgICAgICB2YXIgZW5kSW5kZXggPSBNYXRoLm1heChwcmV2Q2h1bmsuZW5kLCBuZXh0Q2h1bmsuZW5kKTtcblx0XHQgICAgICAgIHByb2Nlc3NlZENodW5rcy5wdXNoKHsgc3RhcnQ6IHByZXZDaHVuay5zdGFydCwgZW5kOiBlbmRJbmRleCB9KTtcblx0XHQgICAgICB9IGVsc2Uge1xuXHRcdCAgICAgICAgcHJvY2Vzc2VkQ2h1bmtzLnB1c2gocHJldkNodW5rLCBuZXh0Q2h1bmspO1xuXHRcdCAgICAgIH1cblx0XHQgICAgICByZXR1cm4gcHJvY2Vzc2VkQ2h1bmtzO1xuXHRcdCAgICB9XG5cdFx0ICB9LCBbXSk7XG5cdFx0XG5cdFx0ICByZXR1cm4gY2h1bmtzO1xuXHRcdH07XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRXhhbWluZSB0ZXh0IGZvciBhbnkgbWF0Y2hlcy5cblx0XHQgKiBJZiB3ZSBmaW5kIG1hdGNoZXMsIGFkZCB0aGVtIHRvIHRoZSByZXR1cm5lZCBhcnJheSBhcyBhIFwiY2h1bmtcIiBvYmplY3QgKHtzdGFydDpudW1iZXIsIGVuZDpudW1iZXJ9KS5cblx0XHQgKiBAcmV0dXJuIHtzdGFydDpudW1iZXIsIGVuZDpudW1iZXJ9W11cblx0XHQgKi9cblx0XHR2YXIgZGVmYXVsdEZpbmRDaHVua3MgPSBmdW5jdGlvbiBkZWZhdWx0RmluZENodW5rcyhfcmVmMykge1xuXHRcdCAgdmFyIGF1dG9Fc2NhcGUgPSBfcmVmMy5hdXRvRXNjYXBlLFxuXHRcdCAgICAgIGNhc2VTZW5zaXRpdmUgPSBfcmVmMy5jYXNlU2Vuc2l0aXZlLFxuXHRcdCAgICAgIF9yZWYzJHNhbml0aXplID0gX3JlZjMuc2FuaXRpemUsXG5cdFx0ICAgICAgc2FuaXRpemUgPSBfcmVmMyRzYW5pdGl6ZSA9PT0gdW5kZWZpbmVkID8gaWRlbnRpdHkgOiBfcmVmMyRzYW5pdGl6ZSxcblx0XHQgICAgICBzZWFyY2hXb3JkcyA9IF9yZWYzLnNlYXJjaFdvcmRzLFxuXHRcdCAgICAgIHRleHRUb0hpZ2hsaWdodCA9IF9yZWYzLnRleHRUb0hpZ2hsaWdodDtcblx0XHRcblx0XHQgIHRleHRUb0hpZ2hsaWdodCA9IHNhbml0aXplKHRleHRUb0hpZ2hsaWdodCk7XG5cdFx0XG5cdFx0ICByZXR1cm4gc2VhcmNoV29yZHMuZmlsdGVyKGZ1bmN0aW9uIChzZWFyY2hXb3JkKSB7XG5cdFx0ICAgIHJldHVybiBzZWFyY2hXb3JkO1xuXHRcdCAgfSkgLy8gUmVtb3ZlIGVtcHR5IHdvcmRzXG5cdFx0ICAucmVkdWNlKGZ1bmN0aW9uIChjaHVua3MsIHNlYXJjaFdvcmQpIHtcblx0XHQgICAgc2VhcmNoV29yZCA9IHNhbml0aXplKHNlYXJjaFdvcmQpO1xuXHRcdFxuXHRcdCAgICBpZiAoYXV0b0VzY2FwZSkge1xuXHRcdCAgICAgIHNlYXJjaFdvcmQgPSBlc2NhcGVSZWdFeHBGbihzZWFyY2hXb3JkKTtcblx0XHQgICAgfVxuXHRcdFxuXHRcdCAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHNlYXJjaFdvcmQsIGNhc2VTZW5zaXRpdmUgPyAnZycgOiAnZ2knKTtcblx0XHRcblx0XHQgICAgdmFyIG1hdGNoID0gdm9pZCAwO1xuXHRcdCAgICB3aGlsZSAobWF0Y2ggPSByZWdleC5leGVjKHRleHRUb0hpZ2hsaWdodCkpIHtcblx0XHQgICAgICB2YXIgc3RhcnQgPSBtYXRjaC5pbmRleDtcblx0XHQgICAgICB2YXIgZW5kID0gcmVnZXgubGFzdEluZGV4O1xuXHRcdCAgICAgIC8vIFdlIGRvIG5vdCByZXR1cm4gemVyby1sZW5ndGggbWF0Y2hlc1xuXHRcdCAgICAgIGlmIChlbmQgPiBzdGFydCkge1xuXHRcdCAgICAgICAgY2h1bmtzLnB1c2goeyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH0pO1xuXHRcdCAgICAgIH1cblx0XHRcblx0XHQgICAgICAvLyBQcmV2ZW50IGJyb3dzZXJzIGxpa2UgRmlyZWZveCBmcm9tIGdldHRpbmcgc3R1Y2sgaW4gYW4gaW5maW5pdGUgbG9vcFxuXHRcdCAgICAgIC8vIFNlZSBodHRwOi8vd3d3LnJlZ2V4Z3VydS5jb20vMjAwOC8wNC93YXRjaC1vdXQtZm9yLXplcm8tbGVuZ3RoLW1hdGNoZXMvXG5cdFx0ICAgICAgaWYgKG1hdGNoLmluZGV4ID09IHJlZ2V4Lmxhc3RJbmRleCkge1xuXHRcdCAgICAgICAgcmVnZXgubGFzdEluZGV4Kys7XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9XG5cdFx0XG5cdFx0ICAgIHJldHVybiBjaHVua3M7XG5cdFx0ICB9LCBbXSk7XG5cdFx0fTtcblx0XHQvLyBBbGxvdyB0aGUgZmluZENodW5rcyB0byBiZSBvdmVycmlkZGVuIGluIGZpbmRBbGwsXG5cdFx0Ly8gYnV0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3ZSBleHBvcnQgYXMgdGhlIG9sZCBuYW1lXG5cdFx0ZXhwb3J0cy5maW5kQ2h1bmtzID0gZGVmYXVsdEZpbmRDaHVua3M7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogR2l2ZW4gYSBzZXQgb2YgY2h1bmtzIHRvIGhpZ2hsaWdodCwgY3JlYXRlIGFuIGFkZGl0aW9uYWwgc2V0IG9mIGNodW5rc1xuXHRcdCAqIHRvIHJlcHJlc2VudCB0aGUgYml0cyBvZiB0ZXh0IGJldHdlZW4gdGhlIGhpZ2hsaWdodGVkIHRleHQuXG5cdFx0ICogQHBhcmFtIGNodW5rc1RvSGlnaGxpZ2h0IHtzdGFydDpudW1iZXIsIGVuZDpudW1iZXJ9W11cblx0XHQgKiBAcGFyYW0gdG90YWxMZW5ndGggbnVtYmVyXG5cdFx0ICogQHJldHVybiB7c3RhcnQ6bnVtYmVyLCBlbmQ6bnVtYmVyLCBoaWdobGlnaHQ6Ym9vbGVhbn1bXVxuXHRcdCAqL1xuXHRcdFxuXHRcdHZhciBmaWxsSW5DaHVua3MgPSBleHBvcnRzLmZpbGxJbkNodW5rcyA9IGZ1bmN0aW9uIGZpbGxJbkNodW5rcyhfcmVmNCkge1xuXHRcdCAgdmFyIGNodW5rc1RvSGlnaGxpZ2h0ID0gX3JlZjQuY2h1bmtzVG9IaWdobGlnaHQsXG5cdFx0ICAgICAgdG90YWxMZW5ndGggPSBfcmVmNC50b3RhbExlbmd0aDtcblx0XHRcblx0XHQgIHZhciBhbGxDaHVua3MgPSBbXTtcblx0XHQgIHZhciBhcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoc3RhcnQsIGVuZCwgaGlnaGxpZ2h0KSB7XG5cdFx0ICAgIGlmIChlbmQgLSBzdGFydCA+IDApIHtcblx0XHQgICAgICBhbGxDaHVua3MucHVzaCh7XG5cdFx0ICAgICAgICBzdGFydDogc3RhcnQsXG5cdFx0ICAgICAgICBlbmQ6IGVuZCxcblx0XHQgICAgICAgIGhpZ2hsaWdodDogaGlnaGxpZ2h0XG5cdFx0ICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgIH07XG5cdFx0XG5cdFx0ICBpZiAoY2h1bmtzVG9IaWdobGlnaHQubGVuZ3RoID09PSAwKSB7XG5cdFx0ICAgIGFwcGVuZCgwLCB0b3RhbExlbmd0aCwgZmFsc2UpO1xuXHRcdCAgfSBlbHNlIHtcblx0XHQgICAgdmFyIGxhc3RJbmRleCA9IDA7XG5cdFx0ICAgIGNodW5rc1RvSGlnaGxpZ2h0LmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG5cdFx0ICAgICAgYXBwZW5kKGxhc3RJbmRleCwgY2h1bmsuc3RhcnQsIGZhbHNlKTtcblx0XHQgICAgICBhcHBlbmQoY2h1bmsuc3RhcnQsIGNodW5rLmVuZCwgdHJ1ZSk7XG5cdFx0ICAgICAgbGFzdEluZGV4ID0gY2h1bmsuZW5kO1xuXHRcdCAgICB9KTtcblx0XHQgICAgYXBwZW5kKGxhc3RJbmRleCwgdG90YWxMZW5ndGgsIGZhbHNlKTtcblx0XHQgIH1cblx0XHQgIHJldHVybiBhbGxDaHVua3M7XG5cdFx0fTtcblx0XHRcblx0XHRmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuXHRcdCAgcmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0XHRcblx0XHRmdW5jdGlvbiBlc2NhcGVSZWdFeHBGbihzdHIpIHtcblx0XHQgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csICdcXFxcJCYnKTtcblx0XHR9XG5cdFxuXHQvKioqLyB9KVxuXHQvKioqKioqLyBdKTtcblx0Ly8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXHQgKlxuXHQgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcblx0ICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXHQgKi9cblx0XG5cdGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG5cdCAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG5cdCAgICBTeW1ib2wuZm9yICYmXG5cdCAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG5cdCAgICAweGVhYzc7XG5cdFxuXHQgIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuXHQgICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG5cdCAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuXHQgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcblx0ICB9O1xuXHRcblx0ICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cblx0ICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG5cdCAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuXHQgIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG5cdH0gZWxzZSB7XG5cdCAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cblx0ICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKSgpO1xuXHR9XG5cdFxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyg1KSkpXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXHR2YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cdFxuXHQvLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcblx0Ly8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG5cdC8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcblx0Ly8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblx0XG5cdHZhciBjYWNoZWRTZXRUaW1lb3V0O1xuXHR2YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXHRcblx0ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xuXHR9XG5cdGZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcblx0fVxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuXHQgICAgfVxuXHQgICAgdHJ5IHtcblx0ICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcblx0ICAgICAgICB9XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcblx0ICAgIH1cblx0fSAoKSlcblx0ZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcblx0ICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG5cdCAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG5cdCAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcblx0ICAgIH1cblx0ICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG5cdCAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcblx0ICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcblx0ICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuXHQgICAgfVxuXHQgICAgdHJ5IHtcblx0ICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG5cdCAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcblx0ICAgIH0gY2F0Y2goZSl7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG5cdCAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcblx0ICAgICAgICB9IGNhdGNoKGUpe1xuXHQgICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuXHQgICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHRcblx0XG5cdH1cblx0ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuXHQgICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG5cdCAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG5cdCAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuXHQgICAgfVxuXHQgICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuXHQgICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG5cdCAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuXHQgICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcblx0ICAgIH1cblx0ICAgIHRyeSB7XG5cdCAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuXHQgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcblx0ICAgIH0gY2F0Y2ggKGUpe1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcblx0ICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG5cdCAgICAgICAgfSBjYXRjaCAoZSl7XG5cdCAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuXHQgICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG5cdCAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdFxuXHRcblx0fVxuXHR2YXIgcXVldWUgPSBbXTtcblx0dmFyIGRyYWluaW5nID0gZmFsc2U7XG5cdHZhciBjdXJyZW50UXVldWU7XG5cdHZhciBxdWV1ZUluZGV4ID0gLTE7XG5cdFxuXHRmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG5cdCAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBkcmFpbmluZyA9IGZhbHNlO1xuXHQgICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcblx0ICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG5cdCAgICB9XG5cdCAgICBpZiAocXVldWUubGVuZ3RoKSB7XG5cdCAgICAgICAgZHJhaW5RdWV1ZSgpO1xuXHQgICAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuXHQgICAgaWYgKGRyYWluaW5nKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG5cdCAgICBkcmFpbmluZyA9IHRydWU7XG5cdFxuXHQgICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcblx0ICAgIHdoaWxlKGxlbikge1xuXHQgICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuXHQgICAgICAgIHF1ZXVlID0gW107XG5cdCAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuXHQgICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG5cdCAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuXHQgICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcblx0ICAgIH1cblx0ICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG5cdCAgICBkcmFpbmluZyA9IGZhbHNlO1xuXHQgICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHR9XG5cdFxuXHRwcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuXHQgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXHQgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcblx0ICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG5cdCAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcblx0ICAgIH1cblx0fTtcblx0XG5cdC8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcblx0ZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG5cdCAgICB0aGlzLmZ1biA9IGZ1bjtcblx0ICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcblx0fVxuXHRJdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcblx0fTtcblx0cHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcblx0cHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcblx0cHJvY2Vzcy5lbnYgPSB7fTtcblx0cHJvY2Vzcy5hcmd2ID0gW107XG5cdHByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xuXHRwcm9jZXNzLnZlcnNpb25zID0ge307XG5cdFxuXHRmdW5jdGlvbiBub29wKCkge31cblx0XG5cdHByb2Nlc3Mub24gPSBub29wO1xuXHRwcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcblx0cHJvY2Vzcy5vbmNlID0gbm9vcDtcblx0cHJvY2Vzcy5vZmYgPSBub29wO1xuXHRwcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcblx0cHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xuXHRwcm9jZXNzLmVtaXQgPSBub29wO1xuXHRwcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5cdHByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cdFxuXHRwcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cdFxuXHRwcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xuXHR9O1xuXHRcblx0cHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcblx0cHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG5cdH07XG5cdHByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHsvKipcblx0ICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG5cdCAqXG5cdCAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuXHQgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cdCAqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIGVtcHR5RnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHR2YXIgaW52YXJpYW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblx0dmFyIHdhcm5pbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHR2YXIgYXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cdFxuXHR2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblx0dmFyIGNoZWNrUHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG5cdCAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuXHQgIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcblx0ICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblx0XG5cdCAgLyoqXG5cdCAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuXHQgICAqXG5cdCAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG5cdCAgICpcblx0ICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuXHQgICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuXHQgICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcblx0ICAgKiAgICAgICAuLi5cblx0ICAgKiAgICAgfVxuXHQgICAqXG5cdCAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG5cdCAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuXHQgICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcblx0ICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICByZXR1cm4gaXRlcmF0b3JGbjtcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIC8qKlxuXHQgICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG5cdCAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcblx0ICAgKlxuXHQgICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcblx0ICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cdCAgICogICAgIHByb3BUeXBlczoge1xuXHQgICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cblx0ICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuXHQgICAqXG5cdCAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuXHQgICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcblx0ICAgKlxuXHQgICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuXHQgICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcblx0ICAgKiAgICAgfSxcblx0ICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cblx0ICAgKiAgIH0pO1xuXHQgICAqXG5cdCAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuXHQgICAqXG5cdCAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG5cdCAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG5cdCAgICpcblx0ICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG5cdCAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuXHQgICAqXG5cdCAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cdCAgICogICAgcHJvcFR5cGVzOiB7XG5cdCAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG5cdCAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcblx0ICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblx0ICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG5cdCAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcblx0ICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuXHQgICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcblx0ICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcblx0ICAgKiAgICAgICAgICApO1xuXHQgICAqICAgICAgICB9XG5cdCAgICogICAgICB9XG5cdCAgICogICAgfSxcblx0ICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cblx0ICAgKiAgfSk7XG5cdCAgICpcblx0ICAgKiBAaW50ZXJuYWxcblx0ICAgKi9cblx0XG5cdCAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+Jztcblx0XG5cdCAgLy8gSW1wb3J0YW50IVxuXHQgIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cblx0ICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG5cdCAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG5cdCAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuXHQgICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG5cdCAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcblx0ICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuXHQgICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG5cdCAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblx0XG5cdCAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG5cdCAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG5cdCAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcblx0ICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG5cdCAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuXHQgICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG5cdCAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuXHQgICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuXHQgICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG5cdCAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcblx0ICB9O1xuXHRcblx0ICAvKipcblx0ICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG5cdCAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG5cdCAgICovXG5cdCAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXHQgIGZ1bmN0aW9uIGlzKHgsIHkpIHtcblx0ICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cblx0ICAgIGlmICh4ID09PSB5KSB7XG5cdCAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuXHQgICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuXHQgICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuXHQgICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuXHQgICAgfVxuXHQgIH1cblx0ICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblx0XG5cdCAgLyoqXG5cdCAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuXHQgICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG5cdCAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuXHQgICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcblx0ICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG5cdCAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHQgICAgdGhpcy5zdGFjayA9ICcnO1xuXHQgIH1cblx0ICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG5cdCAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cdFxuXHQgIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG5cdCAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXHQgICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcblx0ICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuXHQgICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG5cdCAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblx0XG5cdCAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG5cdCAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcblx0ICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuXHQgICAgICAgICAgaW52YXJpYW50KFxuXHQgICAgICAgICAgICBmYWxzZSxcblx0ICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuXHQgICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcblx0ICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG5cdCAgICAgICAgICApO1xuXHQgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuXHQgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuXHQgICAgICAgICAgaWYgKFxuXHQgICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG5cdCAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuXHQgICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcblx0ICAgICAgICAgICkge1xuXHQgICAgICAgICAgICB3YXJuaW5nKFxuXHQgICAgICAgICAgICAgIGZhbHNlLFxuXHQgICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcblx0ICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuXHQgICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG5cdCAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG5cdCAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXG5cdCAgICAgICAgICAgICAgcHJvcEZ1bGxOYW1lLFxuXHQgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcblx0ICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG5cdCAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcblx0ICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG5cdCAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblx0XG5cdCAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcblx0ICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblx0ICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcblx0ICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcblx0ICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcblx0ICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cblx0ICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG5cdCAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblx0XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuXHQgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsKTtcblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG5cdCAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG5cdCAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG5cdCAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG5cdCAgICAgIH1cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG5cdCAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgICAgIHJldHVybiBlcnJvcjtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG5cdCAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG5cdCAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuXHQgICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcblx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuXHQgICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuXHQgICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG5cdCAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcblx0ICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcblx0ICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcblx0ICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuXHQgICAgfVxuXHRcblx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuXHQgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG5cdCAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG5cdCAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG5cdCAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcblx0ICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG5cdCAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG5cdCAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuXHQgICAgICB9XG5cdCAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcblx0ICAgICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0ICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG5cdCAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuXHQgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG5cdCAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuXHQgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG5cdCAgICB9XG5cdFxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcblx0ICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgd2FybmluZyhcblx0ICAgICAgICAgIGZhbHNlLFxuXHQgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcblx0ICAgICAgICAgICdyZWNlaXZlZCAlcyBhdCBpbmRleCAlcy4nLFxuXHQgICAgICAgICAgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpLFxuXHQgICAgICAgICAgaVxuXHQgICAgICAgICk7XG5cdCAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcblx0ICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG5cdCAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG5cdCAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG5cdCAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcblx0ICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblx0ICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcblx0ICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcblx0ICAgICAgfVxuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuXHQgICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuXHQgICAgICAgIGlmICghY2hlY2tlcikge1xuXHQgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcblx0ICAgICAgICBpZiAoZXJyb3IpIHtcblx0ICAgICAgICAgIHJldHVybiBlcnJvcjtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG5cdCAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcblx0ICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblx0ICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcblx0ICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcblx0ICAgICAgfVxuXHQgICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuXHQgICAgICAvLyBwcm9wcy5cblx0ICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG5cdCAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG5cdCAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG5cdCAgICAgICAgaWYgKCFjaGVja2VyKSB7XG5cdCAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG5cdCAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcblx0ICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcblx0ICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG5cdCAgICAgICAgICApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG5cdCAgICAgICAgaWYgKGVycm9yKSB7XG5cdCAgICAgICAgICByZXR1cm4gZXJyb3I7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG5cdCAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcblx0ICAgICAgY2FzZSAnbnVtYmVyJzpcblx0ICAgICAgY2FzZSAnc3RyaW5nJzpcblx0ICAgICAgY2FzZSAndW5kZWZpbmVkJzpcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgY2FzZSAnYm9vbGVhbic6XG5cdCAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG5cdCAgICAgIGNhc2UgJ29iamVjdCc6XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuXHQgICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcblx0ICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG5cdCAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcblx0ICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuXHQgICAgICAgICAgdmFyIHN0ZXA7XG5cdCAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcblx0ICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuXHQgICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cblx0ICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuXHQgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG5cdCAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcblx0ICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgZGVmYXVsdDpcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG5cdCAgICAvLyBOYXRpdmUgU3ltYm9sLlxuXHQgICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0XG5cdCAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuXHQgICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0XG5cdCAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG5cdCAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdFxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0XG5cdCAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuXHQgIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuXHQgICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcblx0ICAgICAgcmV0dXJuICdhcnJheSc7XG5cdCAgICB9XG5cdCAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdCAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cblx0ICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG5cdCAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuXHQgICAgICByZXR1cm4gJ29iamVjdCc7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcblx0ICAgICAgcmV0dXJuICdzeW1ib2wnO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHByb3BUeXBlO1xuXHQgIH1cblx0XG5cdCAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuXHQgIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuXHQgIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuXHQgICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG5cdCAgICB9XG5cdCAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuXHQgICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuXHQgICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuXHQgICAgICAgIHJldHVybiAnZGF0ZSc7XG5cdCAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdCAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcHJvcFR5cGU7XG5cdCAgfVxuXHRcblx0ICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG5cdCAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcblx0ICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcblx0ICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuXHQgICAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICAgIGNhc2UgJ2FycmF5Jzpcblx0ICAgICAgY2FzZSAnb2JqZWN0Jzpcblx0ICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuXHQgICAgICBjYXNlICdib29sZWFuJzpcblx0ICAgICAgY2FzZSAnZGF0ZSc6XG5cdCAgICAgIGNhc2UgJ3JlZ2V4cCc6XG5cdCAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuXHQgICAgICBkZWZhdWx0OlxuXHQgICAgICAgIHJldHVybiB0eXBlO1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cblx0ICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG5cdCAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcblx0ICAgICAgcmV0dXJuIEFOT05ZTU9VUztcblx0ICAgIH1cblx0ICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcblx0ICB9XG5cdFxuXHQgIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG5cdCAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cdFxuXHQgIHJldHVybiBSZWFjdFByb3BUeXBlcztcblx0fTtcblx0XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKSlcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXHQvKipcblx0ICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG5cdCAqXG5cdCAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuXHQgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cdCAqXG5cdCAqIFxuXHQgKi9cblx0XG5cdGZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuXHQgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gYXJnO1xuXHQgIH07XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuXHQgKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuXHQgKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuXHQgKi9cblx0dmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cdFxuXHRlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5cdGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcblx0ZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcblx0ZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcblx0ZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cdGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcblx0ICByZXR1cm4gYXJnO1xuXHR9O1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qKlxuXHQgKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cblx0ICpcblx0ICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG5cdCAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cblx0ICpcblx0ICovXG5cdFxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvKipcblx0ICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuXHQgKlxuXHQgKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuXHQgKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcblx0ICogZXhwZWN0aW5nLlxuXHQgKlxuXHQgKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuXHQgKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG5cdCAqL1xuXHRcblx0dmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblx0XG5cdGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG5cdCAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcblx0ICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG5cdCAgICB9XG5cdCAgfTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG5cdCAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblx0XG5cdCAgaWYgKCFjb25kaXRpb24pIHtcblx0ICAgIHZhciBlcnJvcjtcblx0ICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG5cdCAgICAgIHZhciBhcmdJbmRleCA9IDA7XG5cdCAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG5cdCAgICAgIH0pKTtcblx0ICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcblx0ICAgIH1cblx0XG5cdCAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG5cdCAgICB0aHJvdyBlcnJvcjtcblx0ICB9XG5cdH1cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyg1KSkpXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXHQgKlxuXHQgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcblx0ICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXHQgKlxuXHQgKi9cblx0XG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBlbXB0eUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0XG5cdC8qKlxuXHQgKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG5cdCAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcblx0ICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcblx0ICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG5cdCAqL1xuXHRcblx0dmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXHRcblx0aWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcblx0ICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuXHQgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdCAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuXHQgICAgfVxuXHRcblx0ICAgIHZhciBhcmdJbmRleCA9IDA7XG5cdCAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG5cdCAgICB9KTtcblx0ICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcblx0ICAgIH1cblx0ICAgIHRyeSB7XG5cdCAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cblx0ICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG5cdCAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG5cdCAgICB9IGNhdGNoICh4KSB7fVxuXHQgIH07XG5cdFxuXHQgIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG5cdCAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG5cdCAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cblx0ICAgIH1cblx0XG5cdCAgICBpZiAoIWNvbmRpdGlvbikge1xuXHQgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG5cdCAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcblx0ICAgIH1cblx0ICB9O1xuXHR9XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKSlcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qXG5cdG9iamVjdC1hc3NpZ25cblx0KGMpIFNpbmRyZSBTb3JodXNcblx0QGxpY2Vuc2UgTUlUXG5cdCovXG5cdFxuXHQndXNlIHN0cmljdCc7XG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cdHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXHR2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cdFxuXHRmdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0XHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHRcdH1cblx0XG5cdFx0cmV0dXJuIE9iamVjdCh2YWwpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXHRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdFx0dmFyIHRlc3QyID0ge307XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0XHR9KTtcblx0XHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdFx0dmFyIGZyb207XG5cdFx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0XHR2YXIgc3ltYm9scztcblx0XG5cdFx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblx0XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHRvO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKipcblx0ICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG5cdCAqXG5cdCAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuXHQgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cdCAqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXHQgKlxuXHQgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcblx0ICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXHQgKi9cblx0XG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG5cdCAgdmFyIGludmFyaWFudCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdCAgdmFyIHdhcm5pbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHQgIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXHQgIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cblx0ICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG5cdCAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG5cdCAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcblx0ICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcblx0ICAgICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG5cdCAgICAgICAgdmFyIGVycm9yO1xuXHQgICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG5cdCAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuXHQgICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG5cdCAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG5cdCAgICAgICAgICBpbnZhcmlhbnQodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ3RoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAlc2AuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0pO1xuXHQgICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcblx0ICAgICAgICB9IGNhdGNoIChleCkge1xuXHQgICAgICAgICAgZXJyb3IgPSBleDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKTtcblx0ICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuXHQgICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG5cdCAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuXHQgICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblx0XG5cdCAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblx0XG5cdCAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcblx0XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKSlcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qKlxuXHQgKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cblx0ICpcblx0ICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG5cdCAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cblx0ICovXG5cdFxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgZW1wdHlGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cdHZhciBpbnZhcmlhbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHR2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG5cdCAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuXHQgICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcblx0ICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBpbnZhcmlhbnQoXG5cdCAgICAgIGZhbHNlLFxuXHQgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG5cdCAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcblx0ICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG5cdCAgICApO1xuXHQgIH07XG5cdCAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcblx0ICBmdW5jdGlvbiBnZXRTaGltKCkge1xuXHQgICAgcmV0dXJuIHNoaW07XG5cdCAgfTtcblx0ICAvLyBJbXBvcnRhbnQhXG5cdCAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG5cdCAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuXHQgICAgYXJyYXk6IHNoaW0sXG5cdCAgICBib29sOiBzaGltLFxuXHQgICAgZnVuYzogc2hpbSxcblx0ICAgIG51bWJlcjogc2hpbSxcblx0ICAgIG9iamVjdDogc2hpbSxcblx0ICAgIHN0cmluZzogc2hpbSxcblx0ICAgIHN5bWJvbDogc2hpbSxcblx0XG5cdCAgICBhbnk6IHNoaW0sXG5cdCAgICBhcnJheU9mOiBnZXRTaGltLFxuXHQgICAgZWxlbWVudDogc2hpbSxcblx0ICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG5cdCAgICBub2RlOiBzaGltLFxuXHQgICAgb2JqZWN0T2Y6IGdldFNoaW0sXG5cdCAgICBvbmVPZjogZ2V0U2hpbSxcblx0ICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcblx0ICAgIHNoYXBlOiBnZXRTaGltLFxuXHQgICAgZXhhY3Q6IGdldFNoaW1cblx0ICB9O1xuXHRcblx0ICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGVtcHR5RnVuY3Rpb247XG5cdCAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cdFxuXHQgIHJldHVybiBSZWFjdFByb3BUeXBlcztcblx0fTtcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgc2ltcGxlSXNFcXVhbCA9IGZ1bmN0aW9uIHNpbXBsZUlzRXF1YWwoYSwgYikge1xuXHQgIHJldHVybiBhID09PSBiO1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gaW5kZXggKHJlc3VsdEZuKSB7XG5cdCAgdmFyIGlzRXF1YWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHNpbXBsZUlzRXF1YWw7XG5cdFxuXHQgIHZhciBsYXN0VGhpcyA9IHZvaWQgMDtcblx0ICB2YXIgbGFzdEFyZ3MgPSBbXTtcblx0ICB2YXIgbGFzdFJlc3VsdCA9IHZvaWQgMDtcblx0ICB2YXIgY2FsbGVkT25jZSA9IGZhbHNlO1xuXHRcblx0ICB2YXIgaXNOZXdBcmdFcXVhbFRvTGFzdCA9IGZ1bmN0aW9uIGlzTmV3QXJnRXF1YWxUb0xhc3QobmV3QXJnLCBpbmRleCkge1xuXHQgICAgcmV0dXJuIGlzRXF1YWwobmV3QXJnLCBsYXN0QXJnc1tpbmRleF0pO1xuXHQgIH07XG5cdFxuXHQgIHZhciByZXN1bHQgPSBmdW5jdGlvbiByZXN1bHQoKSB7XG5cdCAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbmV3QXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHQgICAgICBuZXdBcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHQgICAgfVxuXHRcblx0ICAgIGlmIChjYWxsZWRPbmNlICYmIGxhc3RUaGlzID09PSB0aGlzICYmIG5ld0FyZ3MubGVuZ3RoID09PSBsYXN0QXJncy5sZW5ndGggJiYgbmV3QXJncy5ldmVyeShpc05ld0FyZ0VxdWFsVG9MYXN0KSkge1xuXHQgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICBjYWxsZWRPbmNlID0gdHJ1ZTtcblx0ICAgIGxhc3RUaGlzID0gdGhpcztcblx0ICAgIGxhc3RBcmdzID0gbmV3QXJncztcblx0ICAgIGxhc3RSZXN1bHQgPSByZXN1bHRGbi5hcHBseSh0aGlzLCBuZXdBcmdzKTtcblx0ICAgIHJldHVybiBsYXN0UmVzdWx0O1xuXHQgIH07XG5cdFxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gaW5kZXg7XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFpbi5qcy5tYXAiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaWQiLCJsb2FkZWQiLCJjYWxsIiwibSIsImMiLCJwIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX0hpZ2hsaWdodGVyIiwiX0hpZ2hsaWdodGVyMiIsIl9leHRlbmRzIiwiYXNzaWduIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiSGlnaGxpZ2h0ZXIiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJrZXlzIiwiaW5kZXhPZiIsIl9oaWdobGlnaHRXb3Jkc0NvcmUiLCJfcHJvcFR5cGVzIiwiX3Byb3BUeXBlczIiLCJfcmVhY3QiLCJfbWVtb2l6ZU9uZSIsIl9tZW1vaXplT25lMiIsInByb3BUeXBlcyIsImFjdGl2ZUNsYXNzTmFtZSIsInN0cmluZyIsImFjdGl2ZUluZGV4IiwibnVtYmVyIiwiYWN0aXZlU3R5bGUiLCJvYmplY3QiLCJhdXRvRXNjYXBlIiwiYm9vbCIsImNsYXNzTmFtZSIsImZpbmRDaHVua3MiLCJmdW5jIiwiaGlnaGxpZ2h0Q2xhc3NOYW1lIiwib25lT2ZUeXBlIiwiaGlnaGxpZ2h0U3R5bGUiLCJoaWdobGlnaHRUYWciLCJub2RlIiwic2FuaXRpemUiLCJzZWFyY2hXb3JkcyIsImFycmF5T2YiLCJpbnN0YW5jZU9mIiwiUmVnRXhwIiwiaXNSZXF1aXJlZCIsInRleHRUb0hpZ2hsaWdodCIsInVuaGlnaGxpZ2h0VGFnIiwidW5oaWdobGlnaHRDbGFzc05hbWUiLCJ1bmhpZ2hsaWdodFN0eWxlIiwiX3JlZiIsIl9yZWYkYWN0aXZlQ2xhc3NOYW1lIiwidW5kZWZpbmVkIiwiX3JlZiRhY3RpdmVJbmRleCIsIl9yZWYkY2FzZVNlbnNpdGl2ZSIsImNhc2VTZW5zaXRpdmUiLCJfcmVmJGhpZ2hsaWdodENsYXNzTmFtZSIsIl9yZWYkaGlnaGxpZ2h0U3R5bGUiLCJfcmVmJGhpZ2hsaWdodFRhZyIsIl9yZWYkdW5oaWdobGlnaHRUYWciLCJfcmVmJHVuaGlnaGxpZ2h0Q2xhc3NOYW1lIiwicmVzdCIsImNodW5rcyIsImZpbmRBbGwiLCJIaWdobGlnaHRUYWciLCJoaWdobGlnaHRJbmRleCIsImhpZ2hsaWdodENsYXNzTmFtZXMiLCJoaWdobGlnaHRTdHlsZXMiLCJsb3dlcmNhc2VQcm9wcyIsIm1hcHBlZCIsInRvTG93ZXJDYXNlIiwibWVtb2l6ZWRMb3dlcmNhc2VQcm9wcyIsImNyZWF0ZUVsZW1lbnQiLCJjaGlsZHJlbiIsIm1hcCIsImNodW5rIiwiaW5kZXgiLCJ0ZXh0Iiwic3Vic3RyIiwic3RhcnQiLCJlbmQiLCJoaWdobGlnaHQiLCJoaWdobGlnaHRDbGFzcyIsImlzQWN0aXZlIiwicHJvcHMiLCJzdHlsZSIsIl91dGlscyIsImVudW1lcmFibGUiLCJnZXQiLCJjb21iaW5lQ2h1bmtzIiwiZmlsbEluQ2h1bmtzIiwiX3JlZiRmaW5kQ2h1bmtzIiwiZGVmYXVsdEZpbmRDaHVua3MiLCJjaHVua3NUb0hpZ2hsaWdodCIsInRvdGFsTGVuZ3RoIiwiX3JlZjIiLCJzb3J0IiwiZmlyc3QiLCJzZWNvbmQiLCJyZWR1Y2UiLCJwcm9jZXNzZWRDaHVua3MiLCJuZXh0Q2h1bmsiLCJwcmV2Q2h1bmsiLCJwb3AiLCJlbmRJbmRleCIsIk1hdGgiLCJtYXgiLCJwdXNoIiwiX3JlZjMiLCJfcmVmMyRzYW5pdGl6ZSIsImlkZW50aXR5IiwiZmlsdGVyIiwic2VhcmNoV29yZCIsImVzY2FwZVJlZ0V4cEZuIiwicmVnZXgiLCJtYXRjaCIsImV4ZWMiLCJsYXN0SW5kZXgiLCJfcmVmNCIsImFsbENodW5rcyIsImFwcGVuZCIsImZvckVhY2giLCJzdHIiLCJyZXBsYWNlIiwicHJvY2VzcyIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlN5bWJvbCIsImZvciIsImlzVmFsaWRFbGVtZW50IiwiJCR0eXBlb2YiLCJ0aHJvd09uRGlyZWN0QWNjZXNzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZSIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImNvbmNhdCIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiQXJyYXkiLCJJdGVtIiwiYXJyYXkiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwiZW1wdHlGdW5jdGlvbiIsImludmFyaWFudCIsIndhcm5pbmciLCJSZWFjdFByb3BUeXBlc1NlY3JldCIsImNoZWNrUHJvcFR5cGVzIiwiSVRFUkFUT1JfU1lNQk9MIiwiaXRlcmF0b3IiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwiaXRlcmF0b3JGbiIsIkFOT05ZTU9VUyIsIlJlYWN0UHJvcFR5cGVzIiwiY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIiLCJzeW1ib2wiLCJhbnkiLCJjcmVhdGVBbnlUeXBlQ2hlY2tlciIsImNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlciIsImVsZW1lbnQiLCJjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIiLCJjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyIiwiY3JlYXRlTm9kZUNoZWNrZXIiLCJvYmplY3RPZiIsImNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIiLCJvbmVPZiIsImNyZWF0ZUVudW1UeXBlQ2hlY2tlciIsImNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIiLCJzaGFwZSIsImNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIiLCJleGFjdCIsImNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIiLCJpcyIsIngiLCJ5IiwiUHJvcFR5cGVFcnJvciIsIm1lc3NhZ2UiLCJzdGFjayIsImNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyIiwidmFsaWRhdGUiLCJtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSIsIm1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IiwiY2hlY2tUeXBlIiwicHJvcE5hbWUiLCJjb21wb25lbnROYW1lIiwibG9jYXRpb24iLCJwcm9wRnVsbE5hbWUiLCJzZWNyZXQiLCJjb25zb2xlIiwiY2FjaGVLZXkiLCJjaGFpbmVkQ2hlY2tUeXBlIiwiYmluZCIsImV4cGVjdGVkVHlwZSIsInByb3BWYWx1ZSIsInByb3BUeXBlIiwiZ2V0UHJvcFR5cGUiLCJwcmVjaXNlVHlwZSIsImdldFByZWNpc2VUeXBlIiwidGhhdFJldHVybnNOdWxsIiwidHlwZUNoZWNrZXIiLCJpc0FycmF5IiwiZXJyb3IiLCJleHBlY3RlZENsYXNzIiwiZXhwZWN0ZWRDbGFzc05hbWUiLCJhY3R1YWxDbGFzc05hbWUiLCJnZXRDbGFzc05hbWUiLCJleHBlY3RlZFZhbHVlcyIsInZhbHVlc1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJhcnJheU9mVHlwZUNoZWNrZXJzIiwiY2hlY2tlciIsImdldFBvc3RmaXhGb3JUeXBlV2FybmluZyIsImlzTm9kZSIsInNoYXBlVHlwZXMiLCJhbGxLZXlzIiwiZXZlcnkiLCJzdGVwIiwiZW50cmllcyIsIm5leHQiLCJkb25lIiwiZW50cnkiLCJpc1N5bWJvbCIsIkRhdGUiLCJ0eXBlIiwiY29uc3RydWN0b3IiLCJQcm9wVHlwZXMiLCJtYWtlRW1wdHlGdW5jdGlvbiIsImFyZyIsInRoYXRSZXR1cm5zIiwidGhhdFJldHVybnNGYWxzZSIsInRoYXRSZXR1cm5zVHJ1ZSIsInRoYXRSZXR1cm5zVGhpcyIsInRoYXRSZXR1cm5zQXJndW1lbnQiLCJ2YWxpZGF0ZUZvcm1hdCIsImZvcm1hdCIsImNvbmRpdGlvbiIsImEiLCJiIiwiZCIsImYiLCJhcmdJbmRleCIsImZyYW1lc1RvUG9wIiwicHJpbnRXYXJuaW5nIiwiX2xlbiIsIl9rZXkiLCJfbGVuMiIsIl9rZXkyIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcElzRW51bWVyYWJsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwidG9PYmplY3QiLCJ2YWwiLCJUeXBlRXJyb3IiLCJzaG91bGRVc2VOYXRpdmUiLCJ0ZXN0MSIsIlN0cmluZyIsImdldE93blByb3BlcnR5TmFtZXMiLCJ0ZXN0MiIsImZyb21DaGFyQ29kZSIsIm9yZGVyMiIsIm4iLCJqb2luIiwidGVzdDMiLCJzcGxpdCIsImxldHRlciIsImVyciIsImZyb20iLCJ0byIsInN5bWJvbHMiLCJzIiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJleCIsInNoaW0iLCJnZXRTaGltIiwicmVxdWlyZSIsInNpbXBsZUlzRXF1YWwiLCJyZXN1bHRGbiIsImlzRXF1YWwiLCJsYXN0VGhpcyIsImxhc3RBcmdzIiwibGFzdFJlc3VsdCIsImNhbGxlZE9uY2UiLCJpc05ld0FyZ0VxdWFsVG9MYXN0IiwibmV3QXJnIiwicmVzdWx0IiwibmV3QXJncyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-highlight-words/dist/main.js\n");

/***/ })

};
;